- 数据库基础
  collapsed:: true
	- 数据库锁机制
		- 参考文章
			- [MySql: 表级锁、行级锁、共享锁、排他锁、乐观锁、悲观锁](https://blog.csdn.net/hanchao5272/article/details/98607314)
	- SQL程序语言有四种类型
		- DDL
			- Data Definition Language，数据定义语言。
			- 即数据定义语言，定义语言就是定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等。
			- 包括：`create`、`alter`、`drop`、`truncate`
		- DML
			- Data Manipulation Language，数据操作语言。
			- 主要是进行插入元组、删除元组、修改元组的操作。
			- 包括：`insert`、`update`、`delete`
		- DQL
			- Data Query Language，数据查询语言。
			- 用来进行数据库中数据的查询的，即最常用的select语句。
			- 包括：`select`
		- DCL
			- Data Control Language，数据控制语言。
			- 用来授权或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，能够对数据库进行监视。
			- 包括：
				- 创建用户
				- 给用户授权
				- 撤销授权
				- 查看用户权限
				- 删除用户
				- 修改用户密码
- MySQL数据手册
  collapsed:: true
	- 资料信息
		- [MySQL 8.0 Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/features.html)
	- 一般信息
		- 1.2 MySQL 数据库管理系统概述
			- [什么是MySQL](https://dev.mysql.com/doc/refman/8.0/en/what-is-mysql.html)
			  collapsed:: true
				- MySQL是一个数据库管理系统
				- MySQL是一个关系型数据库
				- MySQL是开源的
				- MySQL 数据库服务器非常快速，可靠，可伸缩，易于使用的
				- MySQL 服务器工作在客户端/服务器或嵌入式系统中
				- 有很多应用程序和编程语言支持MySQL
			- [MySQL的主要功能](https://dev.mysql.com/doc/refman/8.0/en/features.html)
			  collapsed:: true
				- 数据类型
				- 语句和函数
				  collapsed:: true
					- 1.支持在SELECT查询参数和WHERE子句中使用运算符和函数。
					- 2.完全支持 SQL GROUP BY 和 ORDER BY 子句。 支持组函数（COUNT()、AVG()、STD()、SUM()、MAX()、MIN() 和 GROUP_CONCAT()）。
					- 3.支持使用标准 SQL 和 ODBC 语法的 LEFT OUTER JOIN 和 RIGHT OUTER JOIN。
					- 4.支持标准 SQL 要求的表和列的别名。
					- 5.支持 DELETE、INSERT、REPLACE 和 UPDATE 以返回更改（受影响）的行数，或通过在连接到服务器时设置标志来返回匹配的行数。
					- 6.支持检索有关数据库、存储引擎、表和索引的信息的 MySQL 特定 SHOW 语句。 支持 INFORMATION_SCHEMA 数据库，根据标准 SQL 实现。
					- 7.EXPLAIN 语句显示优化器如何解析查询。
					- 8.函数名称与表或列名称的独立性。比如：命名不能与保留字重合、函数名与后面(之间不能有空格。
					- 9.可以在同一语句中引用来自不同数据库的表。
				- 安全
				  collapsed:: true
					- 一个非常灵活和安全的权限和密码系统，并且支持基于主机的验证。
					- 当您连接到服务器时，通过加密所有密码流量来实现密码安全性。
				- 可扩展性和限制
				  collapsed:: true
					- 支持大型数据库
					- 每个表最多支持 64 个索引。 每个索引可能由 1 到 16 列或部分列组成。 InnoDB 表的最大索引宽度为 767 字节或 3072 字节。MyISAM 表的最大索引宽度为 1000 字节。索引可以使用 CHAR、VARCHAR、BLOB 或 TEXT 列类型的列前缀。
				- 连通性
				  collapsed:: true
					- 客户端可以使用多种协议连接到 MySQL 服务器：
						- 客户端可以在任何平台上使用 TCP/IP 套接字进行连接。
						- 在 Windows 系统上，如果服务器在启用 named_pipe 系统变量的情况下启动，则客户端可以使用**命名管道**进行连接。 如果在启用 shared_memory 系统变量的情况下启动，Windows 服务器也支持**共享内存**连接。 客户端可以使用 --protocol=memory 选项通过共享内存进行连接。
						- 在 Unix 系统上，客户端可以使用 Unix 域**套接字文件**进行连接。
					- MySQL 客户端程序可以用多种语言编写。
					- Connector/ODBC (MyODBC) 为使用 ODBC（开放式数据库连接）连接的客户端程序提供 MySQL 支持。
					- Connector/J 接口为使用 JDBC 连接的 Java 客户端程序提供 MySQL 支持。
					- MySQL Connector/NET 使开发人员能够轻松创建需要与 MySQL 进行安全、高性能数据连接的 .NET 应用程序。
				- 本土化
					- 服务器可以用多种语言向客户端提供错误消息。
					- 完全支持多种不同的字符集，包括 latin1 (cp1252)、german、big5、ujis、多种 Unicode 字符集等。
					- 所有数据都按所选数据集进行保存。
					- 根据默认的字符集和排序规则进行排序和比较。
					- 服务器时区可以动态更改，各个客户端可以指定自己的时区。
				- 客户端和工具
					- MySQL 包括几个客户端和实用程序。 其中包括命令行程序（例如 mysqldump 和 mysqladmin）和图形程序（例如 MySQL Workbench）。
					- MySQL Server 内置支持 SQL 语句来检查、优化和修复表。 这些语句可通过 mysqlcheck 客户端从命令行获得。 MySQL 还包括 myisamchk，这是一个非常快速的命令行实用程序，用于在 MyISAM 表上执行这些操作。
					- MySQL 程序可以用 --help 或 -? 获得在线帮助的选项。
- MySQL
	- 数据类型
	  collapsed:: true
		- 字符创类型
			- `text`
				- 最大字符长度是65,535 ( 2的16次− 1) 个字符。
			- `mediumtext`
				- 最大的字符长度是16,777,215 (2的24次 − 1) 字符。
			- `longtext`
				- 最大长度是4,294,967,295 or 4GB (2的32次 − 1) 字符。
			- 说到这里，我们就有必要讨论下字节和字符长度的问题
				- `length()`：该函数返回字符串的字节大小。
				- `char_length()`：该函数返回字符串的字符长度。
				- 举个例子来讲，在utf8编码下，**一个汉字字符长度是1，字节大小为3**。
	- 查看数据库隔离级别
	  collapsed:: true
		- 脚本如下
		  ```mysql
		  # MySQL 8.0 之前
		  SELECT @@global.tx_isolation;
		  SELECT @@session.tx_isolation;
		  SELECT @@tx_isolation;
		  
		  # MySQL8.0
		  SELECT @@global.transaction_isolation;
		  SELECT @@session.transaction_isolation;
		  SELECT @@transaction_isolation;
		  ```
	- SQL
	  collapsed:: true
		- 查看建表结构：`show create table <表名>`
		- explain关键字的使用          
		  collapsed:: true
			- 参考文档
				- https://dev.mysql.com/doc/refman/5.7/en/explain-output.html
			- type              
			  
			    > 这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型依次为：system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL
			- system
		- between and日期包含范围边界的查询
		  collapsed:: true
			- 针对datetime和timestamp类型，
			- 针对date类型，
		- 游标-Cursor
		  collapsed:: true
			- 背景
				- MySQL执行检索操作会返回一组称为结果集的行，这组返回的行都是与SQL 语句相匹配的行（零行或多行），但是，使用简单的select 语句，没有办法得到第一行、下一行、或前十行，也不存在一行地处理所有行简单方法（也就是成批地处理它们）,而有时，需要在检索出来的行中前进或后退一行或多行，怎么办来
			- 定义：游标（cursor）是一个存储在mysql服务器上数据库查询，它不是一条select 语句，而是被语句检索出来的结果集。
			- 好处：在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。
			- 主要用于：交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。
		- Select查询
		  collapsed:: true
			- MySQL将 select 查询分为简单查询和复杂查询。复杂查询分为三类：**简单子查询**、**派生表（from语句中的子查询）**、**union 查询**。
		- explain的使用
		  collapsed:: true
			- id列
			  collapsed:: true
				- 定义：id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。
			- select_type列
			  collapsed:: true
				- 定义：select_type 表示对应行是是简单还是复杂的查询。
				- 类型
					- `simple`：简单查询。查询不包含子查询和union。
					- `primary`：复杂查询中最外层的 select。
					- `subquery`：包含在 select 中的子查询（不在 from 子句中）。
					- `derived`：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）
						- 例子：用这个例子来了解 primary、subquery 和 derived 类型
							- SQL：`explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;`
								- `primary`指的就是第一个select
								- `subquery`指的是(select 1 from actor where id = 1)子查询
								- `derived`指的是(select * from film where id = 1)子查询
					- `union`：在 union 中的第二个和随后的 select
					- `union result`：从 union 临时表检索结果的 select
			- table列
			  collapsed:: true
				- 定义：这一列表示 explain 的一行正在访问哪个表。
				- 类型
					- 当 `from`子句中有子查询时，table列是 `<derivenN>` 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。
					- 当有 `union` 时，`UNION RESULT` 的 table 列的值为 <union1,2>，1和2表示参与 union 的 select 行id。
			- type列
			  collapsed:: true
				- 定义：这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。
				- 从最优到最差分别为：`system` > `const` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL`
				- 类型
					- `NULL`：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。
					- `system`：表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index
					- `const`：最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描。
		- `REPLACE SELECT FROM`语句
		  collapsed:: true
			- `REPLACE SELECT FROM`用于将其他表中的数据实时覆盖写入目标表中。写入数据时，根据主键判断待写入的数据是否已经存在于表中，如果已经存在，则先删除该行数据，然后插入新的数据；如果不存在，则直接插入新数据。
		- `INSERT INTO SELECT`语句
		  collapsed:: true
			- `INSERT INTO SELECT` 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。
		- `LOAD DATA`语句
		  collapsed:: true
			- 能快速将一个文本文件的内容导入到对应的数据库表中（一般文本的一行对应表的一条记录）。
	- 索引
	  collapsed:: true
		- 聚集索引（聚簇索引）
			- 定义
				- 指索引项的排序方式和表中数据记录排序方式一致的索引。（以InnoDB聚集索引的主键索引来说，叶子节点中存储的就是行数据，行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的）
				- 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语“聚簇”表示数据行和相邻的键值紧凑的存储在一起。
				- 聚集索引的顺序就是数据的物理存储顺序。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。
			- 特点
				- 因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个。
			- 优点
				- 查询效率快
			- 缺点
				- 修改数据慢
		- 非聚集索引
			- 定义：索引顺序与物理存储顺序不同
	- 运维相关
	  collapsed:: true
		- MySQL配置中`bind-address = 127.0.0.1`的坑
			- `bind-address = 127.0.0.1`的含义就是说mysql只接受localhost，不接受远程连接。在bind-address后面增加远程访问IP地址或者禁掉这句话就可以让远程机登陆访问了。
		- 重启mysql：`service mysql restart`
		- 写入MySQL报错超出 `max_allowed_packet` 的问题
			- MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 `max_allowed_packet` 参数限制，导致大数据写入或者更新失败。
			- 查看sql：`select @@max_allowed_packet;`
	- JDBC
	  collapsed:: true
		- URL参数配置
		  collapsed:: true
			- 示例：`jdbc:mysql://localhost:3306/test?user=root&password=&serverTimezone=Aisa/Shanghai`
			- 参考文章
				- [MySQL JDBC URL参数（转）](https://www.cnblogs.com/EasonJim/p/7659475.html)
				- [mysql官方文档-Configuration Properties](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html)
		- 开发问题
		  collapsed:: true
			- `no suitable driver found for jdbc`在IDEA中使用Tocmat该如何解决
				- 第一步将mysql-connector-java的包放到tomcat的lib目录下，看问题是否解决
				- 若还不行，则看tomcat版本支持的mysql驱动的版本是不是错的，可以看这个[JNDI Datasource How-To](https://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html)
	- MySQL的相关问题
	  collapsed:: true
		- [Mac解决 Can‘t connect to local MySQL server through socket ‘/tmp/mysql.sock‘ (2)问题](https://blog.csdn.net/cxclll/article/details/116024881)
	- 数据库连接池
	  collapsed:: true
		- 数据库连接池最大连接数设置为多少合适：在HikariCP上面有一篇[关于池大小调整](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)的文章
		- 文章中建议池大小的配置为：**(cpu核心数 * 2) + 机械硬盘数量**，影响这个公式的要素主要有四个原因：CPU、磁盘、网络。按照常理来说如果你有一个八核CPU，那么八个连接数是最快的，但是考虑到磁盘和网络的阻塞会造成CPU空闲，所以这里需要乘2加机械硬盘数量。
		- 参考文章
			- [关于数据库连接池，你可能做错了](https://alphahinex.github.io/2021/09/12/about-connection-pool-sizing/)
- H2
  collapsed:: true
	- 参考文章
		- [H2 数据库使用简介](https://www.cnblogs.com/cnjavahome/p/8995650.html)
		- [H2启动器](https://www.jianshu.com/p/f8886c35fa6f)
		- [H2设置自动创建数据库](https://blog.csdn.net/qq_21078159/article/details/108754166)
- 《MySQL 是怎样运行的：从根儿上理解 MySQL》
  collapsed:: true
	- 第一章 重新认识MySQL
	  collapsed:: true
		- 1.启动MySQL的服务器程序
		  collapsed:: true
			- Unix中启动
			  collapsed:: true
				- mysqld
				  collapsed:: true
					- mysqld是一个可执行文件。
					- 在控制台直接输入`mysqld`命令，会直接在控制台上运行MySQL服务。
				- mysqld_safe
				  collapsed:: true
					- `mysqld_safe`是一个启动脚本。
					- 它间接调用了mysqld，它还包括了一个监控进程，如果mysql服务挂了的话可以帮忙重启服务。
					- 此外它会将服务启动时的出错信息保存到出错日志里，方便排查。
				- mysql.server
				  collapsed:: true
					- mysql.server也是一个启动脚本
					- 它会间接调用mysqld_safe。
					- 后面指定`start`参数就可以启动服务器程序，关闭程序可以使用`stop`参数。
				- mysqld_multi
				  collapsed:: true
					- 一台计算机上也可以运行多个服务器实例，也就是运行多个MySQL服务器进程。`mysql_multi`可执行文件可以对每一个服务器进程的启动或停止进行监控。
			- Windows中启动
			  collapsed:: true
				- mysqld
				  collapsed:: true
					- 在windows中MySql的安装目录下也有一个mysqld的可执行文件，双击该文件就可以启动MySQL服务器程序了。
				- 以服务的方式运行服务器程序
				  collapsed:: true
					- 使用命令`mysqld的路径 --install [-manual] [服务名]`来将MySQL作为windows的一个服务。例子`"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --install`
					- `--manual`命令可以省略，加上它的话，windows系统启动的时候就不会自动启动MySQL的服务了。
					- 将MySQL注册为服务之后，我们可以使用命令`net start MySQL`来启动服务了，接着使用`net stop MySQL`来关闭服务。
		- 2.启动MySQL的客户端程序
		  collapsed:: true
			- 可以使用`mysql -h主机名  -u用户名 -p密码`启动客户端来连接服务器端。
		- 3.客户端和服务器端的连接过程
		  collapsed:: true
			- 运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程。
			- MySQL支持下面三种客户端进程和服务器进程的通信方式
			  id:: 64a6b818-7479-426a-a175-fa24189a58ef
			  collapsed:: true
				- TCP/IP
				  collapsed:: true
					- 数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。`MySQL`采用`TCP`作为服务器和客户端之间的网络通信协议。
					- 在网络环境中，客户端进程就可以通过`IP地址`+`端口号`的方式与这个进程连接。
					- 启动客户端程序时在`-h`参数后边紧跟服务器的IP地址，这就意味着客户端和服务器之间需要通过`TCP/IP`网络进行通信。
				- 命名管道和共享内存
				  collapsed:: true
					- 在Windows环境中，我们可以使用**命名管道**和**共享内存**的方式进行通信。
					- MySQL使用**命名管道**来进行进程间通信
					  collapsed:: true
						- 需要在启动服务器程序的命令中加上`--enable-named-pipe`参数，然后在启动客户端程序的命令中加入`--pipe`或者`--protocol=pipe`参数。
					- MySQL使用共享内存来进行进程间通信
					  collapsed:: true
						- 前提是客户端和服务器端在同一台`Windows`主机中。
						- 在启动服务器程序的命令中加上`--shared-memory`参数，在成功启动服务器后，`共享内存`便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入`--protocol=memory`参数来显式的指定使用共享内存进行通信。
				- Unix域套接字文件
				  collapsed:: true
					- 前提是客户端和服务器端在同一台操作系统为类`Unix`的机器上。
					- 如果我们在启动客户端程序的时候`-h`参数指定的主机名为`localhost`，或者指定了`--protocol=socket`的启动参数，那服务器程序和客户端程序之间就可以通过`Unix`域套接字文件来进行通信了。
					- `MySQL`服务器程序默认监听的`Unix`域套接字文件路径为`/tmp/mysql.sock`，客户端程序也默认连接到这个`Unix`域套接字文件。
					- 指定Unix域套接字文件：`mysqld --socket=/tmp/a.txt`。
		- 4.服务器处理客户端请求
		  collapsed:: true
			- 客户端和服务器端通信的本质：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。
			- 服务器端处理客户端查询请求的过程图
			  ![MySQL服务器端处理客户端查询请求.png](../assets/MySQL服务器端处理客户端查询请求_1688648318016_0.png)
			- 连接管理
			  collapsed:: true
				- 客户端采用 ((64a6b818-7479-426a-a175-fa24189a58ef))和服务器端建立连接。
				- 服务器端会专门创建一个线程来处理和客户端的交互。
				- 当客户端和服务器端断开连接之后，服务器端不会立刻把这个交互的线程销毁掉，而是把它缓存了起来。从而节省了开销，避免的线程的频繁创建和销毁。
			- 解析与优化
			  collapsed:: true
				- 查询缓存
				  collapsed:: true
					- 如果两个查询请求的字符串一样，就可以命中缓存，无需接着查询。
					- 如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。
					- 另外，如果查询请求中包含某些**系统函数**、**用户自定义变量**和**函数**、一**些系统表**，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。
					- MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、 `UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或 `DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！
				- 语法解析
				  collapsed:: true
					- 事实上这块内容涉及到了编译器的知识，会涉及到词法分析，语法分析，语义分析等步骤。
				- 查询优化
				  collapsed:: true
					- MySQL会对用户的sql进行优化。
			- 存储引擎
			  collapsed:: true
				- `MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里
				- 为了管理方便，人们把`连接管理`、`查询缓存`、`语法解析`、`查询优化`这些并不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为`存储引擎`的功能。
				- 负责数据的提取和写入。
		- 5.常用的存储引擎
		  collapsed:: true
			- InnoDB：具备外键支持功能的事务存储引擎。
			- MyISAM：主要的非事务处理存储引擎。
		- 6.关于存储引擎的一些操作
		  collapsed:: true
			- 查看当前数据库支持的存储引擎
			  ```sql
			  SHOW ENGINES;
			  ```
			- 设置表的存储引擎
			  collapsed:: true
				- 存储引擎是负责对表中的数据进行提取和写入的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。
			- 创建表时指定存储引擎
			  ```sql
			  CREATE TABLE 表名(
			      建表语句;
			  ) ENGINE = 存储引擎名称;
			  ```
			- 修改表的存储引擎
			  ```sql
			  ALTER TABLE 表名 ENGINE = 存储引擎名称;
			  ```
	- 第二章 MySQL的调控按钮-启动选项和系统变量
		- 1.在命令行中指定启动选项参数
		- 2.在配置文件中指定启动选项参数
	- 第七章 B+树索引的使用
		- 如果索引列在比较表达式中不是以**单独列**的形式出现，而是以某个**表达式**，或者**函数调用形式**出现的话，是用不到索引的。这里的表达式和函数**作用在索引列**的时候才会不走索引。
	- 第九章 InnoDB的表空间结构（没看懂）
	  background-color:: red
	  collapsed:: true
		- 独立表空间的结构
			- 段、组、区都是逻辑结构，表空间和页是物理结构
			- 一个区包含64个页。
			- 一个组包含256个区。
			- 一个索引包含两个段。
			- 段是由若干个零散页面和若干个完整的区组成的。
			- 为什么需要区这个结构：一个区中相邻两个页的物理地址是连续的，减少了随机IO。
			- 为什么需要段这个结构：
			  collapsed:: true
				- 范围查询是对B+树叶子节点的顺序扫描，不需要扫描非叶子节点。所以段区分了叶子节点和非叶子节点。
				- 一个段中叶子节点有自己独有的区，存放非叶子节点的区的集合为一个段。
				- 一个段中非叶子节点有自己独有的区，存放非叶子阶段的取的集合为一个段。
			- 区对应的逻辑结构是XDES，Extent Descriptor Entry
			- 段对应的逻辑结构是INODE
			  collapsed:: true
				- 最重要的是3个List Base Node结构
			- 直属于表空间的三个链表
			- FSP_HDR类型的页
			  collapsed:: true
				- 表空间的第一个页。
				- 存储了直属于表空间的三个链表的基节点。
			- 每个分组的第一个页的结构与FSP_HDR类似，只是表空间的唯一一个FSP_HDR他除了记录XDFS信息外，还记录了表空间的属性。
			- IBUF_BITMAP类型的页
			- INODE类型的页
			  collapsed:: true
				- 为了定位一个`INODE Entry`，存储了INODE Entry结构而存在的。
				- Segment Hader结构：用于记录叶子节点和非叶子节点的段对应的INODE ENTRY结构的地址。
			- 疑问：表空间的三个链表和端的三个链表分别是做什么的，他们有什么区别？
		- 系统表空间的结构
		  collapsed:: true
			- 数据字典表的页结构
	- 第十章 单表访问方法
	  collapsed:: true
		- 访问类型：MySQL执行查询语句的方式
			- const
				- 定义：通过主键或者**唯一**二级索引列来定位**一条**记录的访问方法。
				- 只能匹配一条数据。
				- 这里的唯一指的是通过二级索引查到的数据只有一条，需要回表的数据也只有一条。
				- 如果执行一个唯一二级索引为null的等值查询，因为可能会查到多条数据，所以这个语句不使用const访问方法执行。
			- eq_ref
				- 定义：在**连接查询**中对**被驱动**表**使用主键值或者唯一二级索引列的值进行等值查找**的查询执行方式。
			- ref
				- 定义：通过普通**二级索引**与常数进行等值比较来定位**多条**记录的方法方法。
				- 二级索引列值为null，因为可能查询到多条记录，所以这种情况属于ref的访问方法。
				- 对于联合索引的二级索引，只要是符合**最左匹配原则**且是与**常数的等值比较**，可能采用ref的访问方法。
			- ref_or_null
				- 定义：不仅想找出某个**二级索引列的值等于某个常数**的记录，还想把该列的**值为NULL**的记录也找出来。
			- range
				- 定义：利用索引进行**范围匹配**的访问方法。
			- index
				- 定义：如果查询的字段能够通过**遍历二级索引记录**就能获取而不用回表，我们称这种执行方式为index。
				- 等值查询对应的是**单点区间**，也就是索引列等值匹配的情况
				- 范围查询对应的是**范围区间**，范围区间是为了从索引中获取记录提出的概念。
			- index merge
				- 定义：使用到多个索引来完成一次查询的执行方法。
				- 索引合并算法
					- Intersection合并
					- Union合并
					- Sort-Union合并
			- all
				- 定义：直接扫描聚簇索引进行的全表扫描的查询方式称为all。
		- 注意事项
		  collapsed:: true
			- 一般情况下执行一个查询只会用到单个二级索引。
			- **一个使用到索引的搜索条件**和**没有使用该索引的搜索条件**使用**OR连接**起来后是无法使用该索引的。
			- LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利索引。因为字符串列的二级索引是按照顺序存储了，如果不是前缀匹配就用不到排序了。
			  collapsed:: true
				-
				-
	- 第十一章 连接的原理
		- 连接的本质：将两个表的数据组合起来，即求一个笛卡尔积。
		- 连接的过程
			- 驱动表
				- 一般情况下，MySQL 会选择较小的表作为驱动表。这是因为在连接操作中，需要将驱动表的每一行与被驱动表的每一行进行匹配。如果驱动表较小，则需要匹配的次数较少，因此可以提高查询的效率。
				  例如，如果有两个表 table1 和 table2，table1 有 10 行数据，table2 有 100 行数据，并且连接条件是 table1.column = table2.column，则 MySQL 会选择 table1 作为驱动表。
			- 被驱动表
		- 内连接
			- 驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。
		- 外连接
			- 驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。
			- 连接条件
				- 背景：不想把驱动表的全部记录都加入到最后的结果集。
				- 一般情况下，会把涉及到两张表的过滤条件放到`on`子句中，只涉及单表的过滤条件放到`where`子句中。
		- 内外连接的区别
			- **内连接和外连接的根本区别**就是在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集。
			- 对于内连接而言，两张表谁做驱动表谁做被驱动表，得到的笛卡尔积都是一样的。但是对于外连接，驱动表和被驱动表的关系不能随便更换。
		- 连接的原理
			- 嵌套循环连接（Nested-Loop-Join）
				- 定义：驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式
			- 使用索引加快连接速度
				- 定义：被驱动表利用索引来加快查询速度。
			- 基于块的嵌套循环连接（Block Nested-Loop Join）
				- 背景
				- join buffer：一块存放驱动表结果集的内存。
				- 定义：将被驱动表结果集中的记录装载到join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价。
	- 第十二章 MySQL基于成本的优化
		- 查询成本
			- IO：从磁盘加载数据到内存的时间
			- CPU：读取和检测数据是否满足搜索条件、对结果集进行排序等操作的时间
		- 单表查询的成本
			- 基于成本的优化步骤
				- 根据搜索条件，找出所有可能使用的索引
				- 计算全表扫描的代价
				- 计算使用不同索引执行查询的代价
				- 对比各种执行方案的代价，找出成本最低的那一个
			- 基于index dive的成本计算
				- 定义：通过直接访问索引对应的B+树来计算某个范围区间对应的索引记录条数的方式称之为index dive。
			- 基于索引统计数据的成本计算
				- 触发场景
				  collapsed:: true
					- 使用索引执行查询是会有很多单点区间，也就是说不是范围查询，比如in语句就会产生很多单点区间。
			- 查看一张表的统计数据：`SHOW TABLE STATUS LIKE 'table_name'`
			- 查看一张表索引的统计数据：`SHOW INDEX FROM  table_name`
		- 连接查询的成本
			- MySQL中连接查询采用的是嵌套循环连接算法。
			- 驱动表进行查询后得到的记录条数称之为驱动表的扇出（英文名：fanout）。
			- 两表连接的成本分析
				- 优化重点
					- 尽量减少驱动表的扇出
					- 对被驱动表的访问成本尽量低：尽量在被驱动表的连接列上建立索引
		- 调节成本函数
		  collapsed:: true
			- server层
			- 存储引擎层
	- 第十三章 InnoDB统计数据是如何收集的
	  collapsed:: true
		- `InnoDB`默认是以表为单位来收集和存储统计数据的
		- 统计的数据主要有两块，第一块是表的数据，第二块是索引的数据
		- 基于磁盘的永久性统计数据
		  collapsed:: true
			- 默认采用这种方式来做
		- 基于内存的非永久性统计数据
		  collapsed:: true
			- 这种方式暂时不用了
		- `innodb_stats_method`决定着在统计某个索引列不重复值的数量时如何对待`NULL`值。
	- 第十四章 MySQL基于规则的优化
		- 条件化简
		- 外连接消除
		  collapsed:: true
			- 在外连接查询中，指定的`WHERE`子句中包含被驱动表中的列不为`NULL`值的条件称之为`空值拒绝`（英文名：`reject-NULL`）。
			- 在被驱动表的WHERE子句符合**空值拒绝**的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。
		- 子查询优化
		  collapsed:: true
			- 子查询可以出现的位置
			- 按返回的结果区分子查询
			  collapsed:: true
				- 标量子查询：只返回一个单一值的子查询称之为`标量子查询`。
				- 行子查询：只返回一条记录的子查询。
				- 列子查询：查询出一个列的数据。
				- 表子查询：子查询的结果既包含很多条记录，又包含很多个列。
			- 按照外层查询关系来区分子查询
			  collapsed:: true
				- 外层关系指的就是子查询中有没有用到外层查询的字段。
				- 相关子查询：如果子查询可以单独运行出结果，而不依赖于外层查询的值。
				- 不相关子查询：如果子查询的执行需要依赖于外层查询的值。
			- 子查询在布尔表达式中的使用
			  collapsed:: true
				- 使用`=`、`>`、`<`、`>=`、`<=`、`<>`、`!=`、`<=>`作为布尔表达式的操作符
				  collapsed:: true
					- 注意：这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录。
				- [NOT] IN/ANY/SOME/ALL子查询
				- EXISTS子查询
				  collapsed:: true
					- 功能：仅仅需要判断子查询的结果集中是否有记录。
					- 语法：`[NOT] EXISTS (子查询)`
		- 子查询在MySQL中时怎么执行的
		  collapsed:: true
			- 标量子查询、行子查询的执行方式
			  collapsed:: true
				- 对于包含**不相关**的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。
				- 对于**相关**的标量子查询或者行子查询，先取外层表的第一条记录，然后根据这条记录取内层表去查，然后拿到内层表的数据去匹配外层的where条件。然后取外层表第二条记录，重复上述步骤。
		- in子查询优化
			- 物化：将子查询结果集中的记录保存到临时表的过程。
			- 物化表：把存储子查询结果集的临时表称之为`物化表`。
			- 物化表转连接
			  collapsed:: true
				- 概念解释：可以将in子查询转换为与物化表的连接查询。
				- 半连接（semi-join）：对于外层`s1`表的某条记录来说，我们只关心在内层`s2`表中是否存在与之匹配的记录**是否存在**，而不关心具体有多少条记录与之匹配，最终的结果集中**只保留`s1`表的记录**。
				- 半连接的实现方法
				  collapsed:: true
					- Table pullout （子查询中的表上拉）
					  collapsed:: true
						- 当子查询的查询列表处只有**主键**或者**唯一索引列**时，因为主键或者唯一索引列中的**数据本身就是不重复的**，所以可以直接将子查询转换为连接查询。
					- DuplicateWeedout execution strategy （重复值消除）
					  collapsed:: true
						- 当子查询的查询列没有主键或是唯一索引列时，我们需要为外层s1表建一张临时表，与子查询连接查询时，会将s1表多条满足条件的记录的id添加到临时表中，这个临时表保存的是最后结果集中返回s1表数据的id，通过这种方式消除重复值的实现方法称为des。
					- LooseScan execution strategy （松散索引扫描）
					- Semi-join Materialization execution strategy
					- FirstMatch execution strategy （首次匹配）
				- semi-join的适用条件
				- 不适用于semi-join的情况
		- ANY/ALL子查询优化
		- [NOT] EXISTS子查询的优化
		- 对派生表的优化
			- 我们把放在`FROM`子句中的子查询查询结果称为派生表。
			- 把派生表物化
			- 将派生表和外层的表合并，也就是将查询重写为没有派生表的形式。
	- 第十五章 Explain详解
		- 执行计划各列的详解
			- table：表名
			- id：每个select关键字都对应一个id
			  collapsed:: true
				- 普通查询
				- 连接查询
				- 子查询
				- union
				- union all
			- select_type：查询类型
			- partitions：分区
			- type：对单表的执行查询时的访问方法。
			- possible_keys：可能用到的索引
			- key：实际使用的索引
			- key_len：索引记录的最大长度，为了让我们区分某个使用联合索引的查询具体用了几个索引列。
			- ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。
			- rows：如果是全表查询，代表预计需要扫描的行数；如果是使用索引来查询，代表预计扫描的索引记录行数。
			- filtered：某个表经过搜索条件过滤后剩余记录条数的百分比。该参数和连接查询有关系。
			- extra：额外信息
		- Json格式的执行计划
		  collapsed:: true
			- 作用：为了查看某个执行计划花费的成本的方式。
			- 具体语法：`EXPLAIN FORMAT=JSON <sql语句>`
		- Extend explain
		  collapsed:: true
			- 功能：查询的执行计划有关的一些扩展信息，只能作为帮助我们理解查`MySQL`将如何执行查询语句的一个参考依据而已。
	- 第十七章 optimizer trace表的神器功效
	  collapsed:: true
		- 背景：如果使用explain关键字给出的执行计划和你预期的不一致，可以通过optimizer trace功能更进一步了解MySQL优化器生成执行计划的过程。
		- optimizer trace功能的使用过程
		- 优化的过程被分为三个阶段
		  collapsed:: true
			- `prepare`阶段
			- `optimize`阶段
			- `execute`阶段
		- 对于单表查询，我们主要关注`optimize`阶段的`"rows_estimation"`这个过程，这个过程深入分析了对单表查询的各种执行方案的成本。
		- 对于多表查询，我们更多需要关注`"considered_execution_plans"`这个过程，这个过程里会写明各种不同的连接方式所对应的成本。
	- 第十八章 InnoDB的Buffer Pool
		- 缓存的重要性
		- Buffer Pool
			- 功能
			- 内部组成
				- 控制块
				- 碎片
				- 缓存页
			- free链表的管理
			- 缓存页的哈希处理
			- flush链表的管理
			- LRU链表的管理
			  collapsed:: true
				- 简单的LRU链表：只要我们使用到某个缓存页，就把该缓存页调整到`LRU链表`的头部，这样`LRU链表`尾部就是最近最少使用的缓存页。
				- 划分区域的LRU链表
				  collapsed:: true
					- 存在的问题
					  collapsed:: true
						- 预读
						  collapsed:: true
							- 线性预读
							- 随机预读
							- 优化方案
						- 全表扫描
						  collapsed:: true
							- 优化方案
					- yong区域：一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做`热数据`
					- old区域：一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做`冷数据`
			- 刷新脏页到磁盘
			- 多个Buffer Pool实例
				- 背景：在`Buffer Pool`特别大而且多线程并发访问特别高的情况下，单一的`Buffer Pool`可能会影响请求的处理速度。所以在`Buffer Pool`特别大的时候，我们可以把它们拆分成若干个小的`Buffer Pool`，每个`Buffer Pool`都称为一个`实例`，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。
			- innodb_buffer_pool_size
			  collapsed:: true
				- 背景：Buffer Pool的大小可以在服务器运行时进行调整，调整之后需要将原来的Buffer Pool的数据复制到一块新的空间，是非常耗时的，所以MySQL不支持为Buffer Pool实例申请大块的内存空间。而是以一个所谓的`chunk`为单位向操作系统申请空间。
			- 配置Buffer Pool的注意事项
			- 查看Buffer Pool的状态
	- 第十九章 事务
	  collapsed:: true
		- 事务四大特性
		- 事务的定义
		- 事务的状态
		- MySQL中事务的语法
		  collapsed:: true
			- 开启事务
			  collapsed:: true
				- `BEGIN;`
				- `START TRANSACTION;`
				  collapsed:: true
					- 访问模式
					  collapsed:: true
						- 只读
						- 读写
						- 一致性读
			- 提交事务
			  collapsed:: true
				- `COMMIT;`
			- 手动中止事务（回滚）
			  collapsed:: true
				- `ROLLBACK;`
		- 支持事务的存储引擎
		  collapsed:: true
			- 只有`InnoDB`和`NDB`存储引擎支持。
			- 使用不支持事务的存储引擎的表所做的修改将无法进行回滚。
		- 自动提交
		  collapsed:: true
			- 通过`SHOW VARIABLES LIKE 'autocommit';`查看是否是自动提交的。
			- 关闭`自动提交`功能的两种方法
			  collapsed:: true
				- 显式的的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务。
				- 把系统变量`autocommit`的值设置为`OFF`。
		- 隐式提交
		  collapsed:: true
			- 定义：当我们关闭自动提交功能的前提下，在某些情况下我们执行某些sql语句时，他们会默认提交掉，就像我们使用了`COMMIT;`语句一样。
			- 隐式提交的sql语句
			  collapsed:: true
				- 定义或修改数据库对象的数据定义语言。也就是执行DDL语句时。
				- 隐式使用或修改`mysql`数据库中的表。
				  collapsed:: true
					- 当我们使用`ALTER USER`、`CREATE USER`、`DROP USER`、`GRANT`、`RENAME USER`、`REVOKE`、`SET PASSWORD`等语句时也会隐式的提交前面语句所属于的事务。
				- 事务控制或关于锁定的语句
				- 加载数据的语句
				- 关于`MySQL`复制的一些语句
				- 其它的一些语句
		- 保存点
		  collapsed:: true
			- 作用：如果我们业务逻辑中涉及多步数据库的操作，可能其中某一步会出现问题，为了解决回滚一次性只能回到最初状态的问题，我们可以在执行每一步之后设置一个保存点，如果某一步出现问题，我们执行返回到特定的保存点就行。
			- 语法
			  collapsed:: true
				- 设置保存点：`SAVEPOINT 保存点名称;`
				- 回滚到保存点：`ROLLBACK TO [SAVEPOINT] 保存点名称;`
	- 第二十章 redo日志
	  collapsed:: true
		- 背景
		  collapsed:: true
			- 如果服务器崩溃，内存中的数据未及时刷新到磁盘，会导致数据丢失。为了保证事务的持久性，在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，这样会导致两个问题，一是修改了一个页面的一小部分就刷新一个完整的数据页是浪费资源的，二是将事务修改`Buffer Pool`中的页面刷新到磁盘时，是随机IO，是十分耗时的。
		- 作用
		  collapsed:: true
			- 在事务提交时将重做日志记录顺序写入到磁盘上，如果系统崩溃，重启之后只需要按照磁盘上记录的日志重新将这些日志记录的数据更新磁盘上的数据页上，那么之前事务针对数据库的修改就可以恢复过来。这个过程我们成为重做日志。
		- redo日志的特点
			- `redo`日志占用的**空间非常小**
			- `redo`日志是**顺序写入**磁盘的
		- redo日志内容的格式
		- redo日志的类型
			- 根据写入字节的大小区分的简单日志（大小分别为1，2，4，8，多个字节）类型
			- 复杂日志类型，因为数据库记录的更新可能涉及多个地方的修改，这里针对不同的情况又做了进一步的设计。
		- Mini-Transaction
		  collapsed:: true
			- 定义：
			  collapsed:: true
				- 对底层页面中的一次原子访问的过程称之为一个`Mini-Transaction`，简称`mtr`。
				- 在MySQL写入redo日志的时候，对于复杂日志类型来讲，一条SQL语句的执行可能会涉及多条redo日志的生成操作，这些redo日志的生成操作必须保证其**原子性**，从而才能保证系统崩溃恢复时这一组`redo`日志作为一个不可分割的整体，最终保证数据的完整性。
				- `mtr`运行过程中产生的一组`redo`日志在`mtr`结束时会被复制到`log buffer`中。
		- redo日志的写入过程
		  collapsed:: true
			- redo log block
			  collapsed:: true
				- 定义：`mtr`生成的`redo`日志都放在了大小为`512字节`的`页`中，我们把用来存储`redo`日志的页称为`block`。
				- redo log block的结构
			- redo日志缓冲区
			  collapsed:: true
				- 定义：在服务器启动时就向操作系统申请了一大片称之为`redo log buffer`的连续内存空间，翻译成中文就是`redo日志缓冲区`，我们也可以简称为`log buffer`。这片内存空间被划分成若干个连续的`redo log block`，对存储redo日志的页进行存储。
		- redo日志的刷盘时机
			- redo log buffer 空间不足时
			- 事务提交时
			- 会有一个后台线程不停的将缓冲区的内容刷新到磁盘上
			- 正常关闭服务的时候
		- redo日志文件组
		- redo日志文件格式
		- Log Sequeue Number（日志序列号）
		  collapsed:: true
			- LSN：mtr在记录redo log时，该值表示已经写入到log buffer中redo日志计算的一个序列号。
			- flushed_to_disk_lsn：当前系统已经写入磁盘的`redo`日志量。
		- flush链表中的LSN
		  collapsed:: true
			- oldest_modification：页面被加载到`Buffer Pool`后进行第一次修改，那么就将修改该页面的`mtr`开始时对应的`lsn`值写入这个属性。
			- newest_modification：修改该页面的`mtr`结束时对应的`lsn`值写入这个属性。
		- checkpoint
		  collapsed:: true
			- 背景
			  collapsed:: true
				- `redo`日志文件组容量是有限的，我们不得不选择循环使用`redo`日志文件组中的文件存储，但是这会造成最后写的`redo`日志与最开始写的`redo`日志`追尾`。
				- 判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。
			- 定义：如果`页a`被刷新到了磁盘，`mtr_1`生成的`redo`日志就可以被覆盖了，所以我们可以进行一个增加`checkpoint_lsn`的操作，`checkpoint_lsn`的值取该oldest_modification，我们把这个过程称之为做一次`checkpoint`。
			- 具体实现
			  collapsed:: true
				- 全局变量`checkpoint_lsn`来代表当前系统中可以被覆盖的`redo`日志总量是多少。
		- innodb_flush_log_at_trx_commit的用法
		  collapsed:: true
			- 用来配置：事务提交时，如何将log buffer中的日志及时的同步到磁盘上的行为。
		- 查看系统中的各种LSN值
		- 崩溃恢复
		  collapsed:: true
			- 确定恢复的起点
			  collapsed:: true
				- 我们从日志文件组的第一个文件的管理系统中获取checkpoint1和checkpoint2的值，两者比较，获取值最大的，大的就是最新的一次checkpoint编号，接着从中获取到checkpoint_lsn。
			- 确定恢复的终点
			  collapsed:: true
				- 普通block的`log block header`部分有一个称之为`LOG_BLOCK_HDR_DATA_LEN`的属性，如果该属性的值不是512，那么他就是要扫描的最后一个block。
			- 如何恢复
			  collapsed:: true
				- 使用哈希表
				- 跳过已经刷新到磁盘的页面
		- LOG_BLOCK_HDR_NO是如何计算的
		- redo日志的整体结构： [redo日志的结构.xmind](../assets/redo日志的结构_1707034294820_0.xmind)
	- 第二十一章 undo日志
	  collapsed:: true
		- 背景：事务需要保证原子性，就需要支持事务的回滚，事务的回滚是依赖undo日志来进行实现的。
		- 作用
		  collapsed:: true
			- 事务回滚：记录事务操作过程中的日志，保证事务的原子性。
			- 多版本并发控制：MVCC
		- 事务id
		  collapsed:: true
			- 事务id分配的时机
			  collapsed:: true
				- 针对只读事务
				- 针对读写事务
			- 事务id的生成规则
		- trx_id隐藏列
		- roll_pointer隐藏列
		- undo日志的格式
		- insert操作的undo日志
		  collapsed:: true
			- undo日志类型：类型为`TRX_UNDO_INSERT_REC`的`undo日志`
		- delete操作的undo日志
		  collapsed:: true
			- undo日志类型：`TRX_UNDO_DEL_MARK_REC`类型的`undo日志`
			- 阶段一：delete mask阶段
			- 阶段二：真正删除原有记录，将删除记录加入垃圾链表
		- update操作的undo日志
		  collapsed:: true
			- 不更新主键的情况
			  collapsed:: true
				- undo日志类型：`TRX_UNDO_UPD_EXIST_REC`的`undo日志`
				- 就地更新
				  collapsed:: true
					- 适用条件：更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的**存储空间都一样大**，那么就可以进行`就地更新`。
				- 先删除掉旧记录，在插入新记录
				  collapsed:: true
					- 适用条件：如果有任何一个被更新的列更新前和更新后占用的**存储空间大小不一致**，那么就需要先把这条旧的记录**从聚簇索引页面中删除掉**，然后再根据更新后列的值**创建一条新的记录插入到页面**中。
			- 更新主键的情况
			  collapsed:: true
				- 将旧记录进行`delete mark`操作
				  collapsed:: true
					- undo日志类型：`TRX_UNDO_DEL_MARK_REC`的`undo日志`
				- 根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）
				  collapsed:: true
					- undo日志类型：`TRX_UNDO_INSERT_REC`的`undo日志`
		- 通用链表的结构
		  collapsed:: true
			- List Node的结构
			- List Base Node的结构
		- `FIL_PAGE_UNDO_LOG`页面
		  collapsed:: true
			- 作用：专门用来存储`undo日志`的
			- 页面结构
			  collapsed:: true
				- `Undo Log Header`结构
				  collapsed:: true
					- `TRX_UNDO_PAGE_TYPE`：存储undo日志的类型
					  collapsed:: true
						- `TRX_UNDO_INSERT`：一般由insert语句产生的undo日志
						- `TRX_UNDO_UPDATE`：一般由update、delete语句产生的undo日志
					- `TRX_UNDO_PAGE_NODE`：undo页面链表
		- undo页面链表
		  collapsed:: true
			- 单个事务的undo页面链表
			  collapsed:: true
				- 一个事务执行过程中可能产生很多`undo日志`，这些日志可能一个页面放不下，需要放到多个页面中，这些FIL_PAGE_UNDO_LOG页面就是通过`TRX_UNDO_PAGE_NODE`属性连成了链表。
				- 一个事务执行过程中就可能需要2个`Undo页面`的链表，一个称之为`insert undo链表`，另一个称之为`update undo链表`。
				- 普通表和临时表的记录改动时产生的`undo日志`要分别记录。
				- 一个事务中最多有4个以`Undo页面`为节点组成的链表。
				- 4个链表的分配规则：产生insert或是update操作、使用普通表或是临时表，按需分配。
			- 多个事务的undo页面链表
			  collapsed:: true
				- 不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中。
			- undo页面链表的结构
			  collapsed:: true
				- 结构图
				  ![undo页面链表的结构.png](../assets/undo页面链表的结构_1707188191464_0.png)
				- 第一个`Undo页面`给标了出来，称它为`first undo page`，它的结果如下：
				  collapsed:: true
					- `Undo Page Header`
					- `Undo Log Segment Header`
					- `Undo Log Header`
				- 其余的`Undo页面`称之为`normal undo page`
		- undo日志的具体写入过程
		  collapsed:: true
			- 段的概念
			  collapsed:: true
				- 与之前在表空间中讲到的段的概念不同，在undo日志中，**每一个`Undo页面`链表都对应着一个`段`**，称之为`Undo Log Segment`。换句话说**链表中的页面都是从这个段里边申请的**。
			- `Undo Log Segment Header`的结构
			  collapsed:: true
				- `TRX_UNDO_STATE`：`Undo页面`链表处在什么状态。
				  collapsed:: true
					- `TRX_UNDO_CACHED`：被缓存的状态。处在该状态的`Undo页面`链表等待着之后被其他事务重用。
					- `TRX_UNDO_TO_FREE`：对于`insert undo`链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
					- `TRX_UNDO_TO_PURGE`：对于`update undo`链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
			- `Undo Log Header`的结构
			  collapsed:: true
				- 同一个事务向一个`Undo页面`链表中写入的`undo日志`算是一个组。
		- 重用undo页面
		  collapsed:: true
			- 背景：大部分事务在执行是只修改了一条或是多条记录，undo页面链表只产生了非常少的undo日志，占用了很少的存储空间。如果新建一个事务至少就会创建一个`redo页面`链表，然后这个链表放在一个页面中，这个页面存储了一点点数据，就很浪费空间。
			- undo页面被重用的条件
			  collapsed:: true
				- 该链表中只包含一个`Undo页面`
				- 该`Undo页面`已经使用的空间小于整个页面空间的3/4
			- undo页面重用的逻辑
			  collapsed:: true
				- insert undo链表：只存储类型为`TRX_UNDO_INSERT_REC`的`undo日志`的`FIL_PAGE_UNDO_LOG`页面组成的链表。
				- update undo链表：除了存储类型为`TRX_UNDO_INSERT_REC`外的`undo日志`的`FIL_PAGE_UNDO_LOG`页面组成的链表。
		- 回滚段页面
		  collapsed:: true
			- 作用：为了管理undo页面链表，包括undo页面的分配和复用。
			- `Rollback Segment Header`页面
			  collapsed:: true
				- 每一个`Rollback Segment Header`页面都对应着一个`Rollback Segment`段，翻译过来就是`回滚段`。
				- 页面结构
				  collapsed:: true
					- `TRX_RSEG_UNDO_SLOTS`
					  collapsed:: true
						- 各个`Undo页面`链表的`first undo page`的`页号`集合，也就是`undo slot`集合。
						- 未向任何事务分配任何`Undo页面`链表，所以对于一个`Rollback Segment Header`页面来说，它的各个`undo slot`都被设置成了一个特殊的值：`FIL_NULL`（对应的十六进制就是`0xFFFFFFFF`），表示该`undo slot`不指向任何页面。
			- 从回滚段中获取undo页面链表
			  collapsed:: true
				- 一个`Rollback Segment Header`页面中包含`1024`个`undo slot`。
				- 如何给事务需要分配`Undo页面`链表
				  id:: 65c1dd22-61ba-4960-a14a-bf2aa0dcb76b
				  collapsed:: true
					- 第一步：先去回滚段的第一个`undo slot`开始，看看该`undo slot`的值是不是`FIL_NULL`
					- 第二步：如果为`FIL_NULL`，需要在表空间申请一个段（`Undo Log Segment`），从段中申请一个页面作为`Undo页面`链表的`first undo page`，接着让`undo slot`记录这个页面的页号。
					- 第三步：如果不是`FIL_NULL`，说明该`undo slot`已经指向了一个`undo链表`，也就是说这个`undo slot`已经被别的事务占用了，那就跳到下一个`undo slot`，判断该`undo slot`的值是不是`FIL_NULL`，重复上面的步骤。
				- 当一个事务提交时，它所占用的`undo slot`有两种命运（为页面重用做准备）：
				  collapsed:: true
					- 如果该`undo slot`指向的`Undo页面`链表符合被重用的条件
					  collapsed:: true
						- 该undo链表的`first undo page`的`Undo Log Segment Header`的结构中`TRX_UNDO_STATE`就会被标记为`TRX_UNDO_CACHED`。
						- 根据`undo页面`所在链表的类型的不同，`undo页面`对应的`undo slot`会分别放置到**`insert undo cached`链表**和**`update undo cached`链表**中。
						- 一个回滚段对应两个cached链表，如果有新事务要分配`undo slot`时，先从对应的`cached链表`中找。如果没有被缓存的`undo slot`，才会到回滚段的`Rollback Segment Header`页面中再去找。
					- 如果该`undo slot`指向的`Undo页面`链表不符合被重用的条件
					  collapsed:: true
						- 如果对应的`Undo页面`链表是`insert undo链表`
						- 如果对应的`Undo页面`链表是`update undo链表`
			- 问题：回滚段和上面提到的Undo Log Segment的区别
			  collapsed:: true
				- 回滚段是一个页面
				- Undo Log Segment是一个逻辑结构，这个段与表空间的段时一样的，页面都是从段中申请的。
		- 多个回滚段页面
		  collapsed:: true
			- 背景：一个回滚段页面中TRX_RSEG_UNDO_SLOTS占了4096个字节，而一个事务可能会产生4个undo页面链表，所以一个回滚段只能支持`1024`个读写事务同时执行。
			- 系统表空间的第`5`号页面存储了128个记录回滚段的位置信息。
			- 结构图
			  ![多个回滚段.png](../assets/多个回滚段_1707207057728_0.png)
		- 回滚段的分类
		  collapsed:: true
			- 分类
			  collapsed:: true
				- 对普通表的记录做了改动需要分配undo页面链表涉及的回滚段，分别是第0号（系统表空间）、第`33～127`号（系统表空间/undo表空间）回滚段。
				- 对临时表的记录做了改动需要分配undo页面链表涉及的回滚段，在系统表空间的1-32号回滚段。
			- 针对普通表和临时表划分不同种类的`回滚段`的原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。
		- 为事务分配undo页面链表的详细过程
		  collapsed:: true
			- 流程图
			  ![undolog.png](../assets/undolog_1707295763836_0.png)
			- 第一步：获取回滚段页面
			- 第二步：获取当前回滚段页面的cached链表，如果是insert操作就去insert cached链表中查看是否有已经缓存的undo slot，有的话就把这个undo slot 分给事务，delete和update操作对应update cached链表。
			- 第三步：如果缓存链表中没有，然后就去回滚段的TRX_RSEG_UNDO_SLOTS中查找undo slot，具体的流程参考 ((65c1dd22-61ba-4960-a14a-bf2aa0dcb76b))
			- 第四步：找到undo slot之后，如果这个undo slot是从cached链表中获取的，则这个undo slot已经指向了`first undo page`页面为链表头的链表，直接对页面空间进行复用就行；如果undo slot的值为`FIL_NULL`，就从表空间中获取申请一个新的页面作为`Undo页面`链表的`first undo page`。
		- 回滚段相关配置
		- 参考文章
		  collapsed:: true
			- [MySQL · 引擎特性 · 庖丁解InnoDB之UNDO LOG](http://mysql.taobao.org/monthly/2021/10/01/)
	- 事务的隔离级别与MVCC
		- 事务
			- 定义
			  collapsed:: true
				- 把需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称之为一个`事务`（英文名是：`transaction`）。
				- 把多条语句作为一个整体进行操作的功能，被称为数据库事务。
				- 数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。
			- 四大特性
				- 原子性-Atomic
					- 表示组成一个事物中的多个数据库操作是一个不可分割的原子单元，作为原子工作单元执行，要么全部执行，要么全部不执行。
				- 一致性-Consistent
					- 事务完成后，数据库所处的状态与它的业务规则是一致的，即A账户转账100元到B账户，无论成功与否，A账户和B账户的存款总额是不变的。
				- 隔离性-Isolation
				  collapsed:: true
					- 如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离。
				- 持久性-Duration
				  collapsed:: true
					- 事务完成后，对数据库数据的修改被持久化存储。
			- 具体实现
			  collapsed:: true
				- 数据库采用**redo日志**来保证**一致性**和**持久性**。
				- 数据库采用**undo日志**来保证**原子性**。
				- 数据库采用**MVCC**和**锁机制**保证事务的**隔离性**。
		- 数据并发导致的问题
		  collapsed:: true
			- 3类数据读问题
			  collapsed:: true
				- 脏读（dirty read）
				  id:: 642d322f-4f72-4c9b-875c-2fcc8d125514
				  collapsed:: true
					- A事务读取了B事务尚未提交的更改数据，A事务并在此基础上做了操作。
					- 就是说A事务读了错的数据，并进行了操作，然后A事务提交事务后修改的数据也是错的。
				- 不可重复读（unrepeatable read）
				  collapsed:: true
					- A事务第一次读取了数据
					- B事务已经提交了事务，更改了数据（更新或是删除）
					- A事务第二次读取数据，发现与第一次读取的不一样
				- 幻象读
				  collapsed:: true
					- A事务第一次读取了数据
					- B事务已经提交了事务，新增了数据（新增）
					- A事务第二次读取数据，发现与第一次读取的不一样
				- 不可重复读和幻象读的区别
				  collapsed:: true
					- **不可重复读**是同一条记录的内容被修改了，重点在于**UPDATE**或**DELETE**
					- **幻读**是查询某一个范围的数据行变多了或者少了，重点在于**INSERT**
					- 三采取的解决策略不同
					  collapsed:: true
						- 幻象读，需要防止事务读到新增数据，需要添加表级锁，也就是将整张表锁定，防止新增数据。
						- 不可重复读，需要防止事务读到更改的数据，只需对操作的数据添加行级锁，阻止操作的数据发生变化。
			- 2类数据更新问题
			  collapsed:: true
				- 第一类丢失问题
				  collapsed:: true
					- A事务第一次读取了数据
					- B事务第一次读取了数据，并对数据进行了更新操作，并提交了事务
					- A事务根据第一次读到的数据对其进行了更新操作
					- A事务**撤销了更新操作**，数据恢复为事务A第一次读到的数据
					- 在上述过程中A事物撤销时，将已经提交的B事务的更新数据给覆盖了
				- 第二类丢失问题
				  collapsed:: true
					- A事务第一次读取了数据
					- B事务第一次读取了数据，并对数据进行了更新操作，并提交了事务
					- **A事务根据第一次读到的数据对其进行了更新操作，并提交了事务**
					- 在上述过程中A事物覆盖了B事务已经提交的数据，造成B事物所做操作丢失
		- 数据库的隔离级别
		  collapsed:: true
			- 读未提交（READ UNCOMMITTED）
			  collapsed:: true
				- 定义：就是一个事务可以读取另一个未提交事务的数据。
				- 该隔离级别下，可能会出现**脏读**、**不可重复读**和**幻读**情况。
			- 读提交 （READ COMMITTED）
			  collapsed:: true
				- 定义：就是一个事务要等另一个事务提交后才能读取数据。
				- 该隔离级别下，可能会出现**不可重复读**和**幻读**情况。
			- 可重复读 （REPEATABLE READ）
			  collapsed:: true
				- 定义：就是在开始读取数据（事务开启）时，不再允许修改操作。
				- 该隔离级别下，可能会出现**幻读**，不可能出现**脏读**和**不可重复读**。
			- 串行化 （SERIALIZABLE）
			  collapsed:: true
				- 定义：最高的事务隔离级别，该级别下，事务串行顺序执行。
				- 该隔离级别下，**幻读**、**脏读**和**不可重复读**都不会出现。
			- 参考文章
			  collapsed:: true
				- [MySQL事务隔离级别和实现原理（看这一篇文章就够了！）](https://zhuanlan.zhihu.com/p/117476959)
		- MVCC
		  collapsed:: true
			- 聚簇索引的两个隐藏列
			  collapsed:: true
				- trx_id：事务ID
				- roll_pointer：回滚指针，一个指向记录对应的`undo日志`的一个指针。
			- 版本链
			  collapsed:: true
				- 每条undo日志也有roll_pointer属性(注意插入操作的undo日志没有这个属性，因为它没有老版本)，每次记录被更新后，该属性指向上一次该记录被修改的版本，多个版本的undo日志通过这个属性连接成了一个链表，称为版本链。
			- ReadView
			  collapsed:: true
				- 对于四种隔离级别的事务来讲，事务的隔离性是如何处理的？
				  collapsed:: true
					- 对于读未提交，因为事务可以读取未提交事务的更新，所以直接读取最新的值就行。
					- 对于串行化，因为多个事物的操作是通过锁进行控制的，从而满足了隔离性。
					- 对于读提交和重复读来讲，是通过MVCC或是锁来保证事务的隔离性的。
				- ReadView的核心逻辑
				  collapsed:: true
					- 隔离性的控制内部实现是通过**判断版本链中的哪个版本是当前事务可见的**。当前事务对于生成ReadView**之前未提交的事务**或者**之后才开启的事务**所做的更改是看不到的。
				- 读提交和重复读生成ReadView的时机是不同的
				  collapsed:: true
					- READ COMMITTED —— 每次读取数据前都生成一个ReadView
					- REPEATABLE READ —— 在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。
	- 第二十二章 锁
	  collapsed:: true
		- 1.解决并发事务带来问题的两种基本方式
		  collapsed:: true
			- 这两种方式分别是：MVCC和锁。
			- 并发事务访问相同数据的情况
			  collapsed:: true
				- 读-读情况，不会产生并发问题。
				- 写-写情况，并发事务相继对相同的记录进行改动。
				- 读-写或写-读情况，一个事务进行读或另一个事务进行写。
			- 写-写的情况
			  collapsed:: true
				- 在多个事务并发进行写操作时，可能会出现脏写的现象。
				- 在多个未提交事务相继对同一条记录进行写操作时，需要让它们排队执行，排队是通过加锁来实现的。
				- 锁结构中的重要信息
				  collapsed:: true
					- trx信息：锁结构与事务的关联关系。
					- is_waiting：当前事物是否在等待。
				- 假设事务T1和T2想要对一行数据进行写操作，他们会进行如下步骤
				  collapsed:: true
					- 1.他会判断是否有别的事物对这条数据进行加锁，若没有则会在内存中生成一个锁结构与该记录关联，此时`is_waiting`为`false`，故T1获取锁成功。
					- 2.在T1事务提交之前，此时T2事务来了，首页他会判断是否有别的事物对这条数据进行加锁，因为T1的存在，所以T2需要等待，此时也会为T2生成一个锁结构来与该记录关联，此时`is_waiting`为`true`，故T2加锁失败。
					- 3.T1事务提交之后，他会去看看是否与该记录关联的锁在等待，若有的话，他会将T2所在的线程唤醒，此时T2会将`is_waiting`改为`false`，此时T2获取锁成功。
			- 读-写和写-读的情况
			  collapsed:: true
				- 在SQL标准中规定了读未提交，读提交，可重复读和串行化4种不同的事务隔离级别，这里会涉及到脏读、不可重复读和幻读3类数据读问题。
				- 解决三类数据读取问题的方案
				  collapsed:: true
					- 方案一：读操作采取多版本并发控制（MVVC），写操作采取加锁方式
					  collapsed:: true
						- MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。其原理就是生成一个ReadView，ReadView中保存着符合条件的记录版本（记录版本是由undo日志构建的），查询语句只能查到**生成ReadView之前**已提交事务所做的修改，未提交的事务或是后面才开启的事务所在更改时看不到的。
						- 在读提交和可重复读的隔离级别下会使用**MVCC读取数据**。
						- 在**读提交隔离**级别下，一个事务每次执行SELECT语句，都会生成一个ReadView。这样每一个事物是不可能读取到为提交的事务，从而不会发生脏读的情况。
						- 在**可重复读**隔离级别下，一个事务只有在第一次执行SELECT语句时，才会生成一个ReadView，之后的SELECT操作都会复用该ReadView，一个事务只能查到第一次SELECT之前已经提交事务的数据，那么就不会出现脏读、不可重复读和幻读的情况了。
						- **值得注意**的是MVCC在可重复读隔离级别下，**最大可能**的规避了幻读，但不是万千规避。
					- 方案二：读写操作都采取加锁的方式
					  collapsed:: true
						- 在银行转账的场景中，我们会读取账户的余额信息，然后并对余额信息就行修改。在此期间不允许被人对这条数据进行访问和修改，所以读写操作都要加锁，都要进行排队执行。
						- 这种方式相比于方案一性能开销过大，并发能力也比较低。
			- 一致性读
			  collapsed:: true
				- 事务利用MVCC进行的读取操作称为一致性读（Consistent read），一致性读不会对表中的任何记录进行加锁操作。
				- 所有普通的SELECT语句在读提交和重复读隔离级别下都算是一致性读。
			- 锁定读
			  collapsed:: true
				- 共享锁和独占锁
				  collapsed:: true
					- 背景：MySQL按照并发场景将锁分为共享锁和独占锁。
					- 共享锁（Shared Lock）：简称S锁，在事务读取一条记录时，需要获取该记录的S锁。
					- 排他锁（Exclusive Lock）：简称X锁，在事务改动一条记录时，需要先获取该记录的X锁。
					- 共享锁和排他锁的兼容关系
					  collapsed:: true
						- 图
						  ![共享锁和排他锁.png](../assets/共享锁和排他锁_1690206273268_0.png)
						- 简单解释一下，比如事务T1获取了一条记录的S锁，之后事务T2想要获取该记录的X锁就不行了，该操作会被阻塞；如果T2事务想要获取该记录的S锁是可以的。
				- 锁定读的语句
				  collapsed:: true
					- 背景：MySQL提供了两种特殊的SELECT语句来支持锁定读。
					- 一对读取的记录加S锁
					  collapsed:: true
						- sql：`SELECT ... LOCK IN SHARE MODE;`
					- 二对读取的记录加X锁
					  collapsed:: true
						- sql：`SELECT ... FOR UPDATE;`
				- 写操作
				  collapsed:: true
					- DELETE的执行过程
					  collapsed:: true
						- 1.先在B+树中定位这条记录的位置。
						- 2.获取这条记录的X锁（获得锁定读）。
						- 3.进行删除操作。
					- UPDATE
					  collapsed:: true
						- 若未修改该记录行涉及的键值且记录每列所占的存储空间在修改前后并未变化
						  collapsed:: true
							- 1.先在B+树中定位这条记录的位置。
							- 2.获取这条记录的X锁（获得锁定读）。
							- 3.在原记录的位置进行修改操作。
						- 若未修改该记录行涉及的键值且至少有一个被更新的列的存储空间在修改前后发送了变化
						  collapsed:: true
							- 1.先在B+树中定位这条记录的位置。
							- 2.获取这条记录的X锁（获得锁定读）。
							- 3.将该条记录删除。
							- 4.插入一条新的记录。
						- 若修改了该记录行的键值
						  collapsed:: true
							- 1.在原记录上执行DELETE操作。
							- 2.进行INSERT操作。
					- INSERT
					  collapsed:: true
						- 一般情况下，新插入一条记录受隐式锁保护，不需要内存为其生成对应的索结构。
		- 2.多粒度锁
		  collapsed:: true
			- 表级锁
			  collapsed:: true
				- 共享锁和独占锁
				  collapsed:: true
					- 共享锁（S锁）
					- 独占锁（X锁）
				- 意向锁（Intention lock）
				  collapsed:: true
					- 作用：IS锁和IX锁时表级锁，是为了在添加**表级别**的S锁和X锁时可以快速的判断出表中的记录是否上锁，以避免使用遍历的方式来查看表中有没有上锁的记录。也就是说IS锁和IX锁是兼容的，IX锁和IX锁也是兼容的。
					- 意向共享锁（Intention Shared Lock）
					  collapsed:: true
						- 简称IS锁，当事务准备在某条记录上加S锁时，需要先在表级别上加一个IS锁。
					- 意向独占锁（Intention Exclusive Lock）
					  collapsed:: true
						- 简称IX锁，当事务准备在某条记录上加X锁时，需要先在表级别上加一个IX锁。
				- 表级别锁的兼容性
				  collapsed:: true
					- 图
					  ![表级别锁的兼容性.png](../assets/表级别锁的兼容性_1690262816304_0.png)
		- 3.MySQL中的行锁和表锁
			- InnoDB引擎中的表级别锁
			  collapsed:: true
				- 表级别的S锁、X锁
				  collapsed:: true
					- 首先值得注意的是，InnoDB引擎**不会**为SELECT、INSERT、UPDATE、DELETE语句的执行添加表级别的S锁和X锁。
					- 元数据锁
					  collapsed:: true
						- 在两个事务同时对同一张表进行操作时，第一个事务在执行DDL语句，另一个事物在执行DML语句，这两个事物会发生阻塞，若第一个事务操作在前则第二个事务被阻塞，若第二个事务操作在前，第一个事务被阻塞。
						- 这个阻塞的逻辑是由Server层的元数据锁（Metadata Lock，MDL）来实现的。
					- 手动获取InnoDB存储的S锁和X锁
					  collapsed:: true
						- `LOCK TABLES t READ`：InnoDB会对表t添加表级别S锁。
						- `LOCK TABLES t WRITE`：InnoDB会对表t添加表级别的X锁。
				- 表级别的IS锁、IX锁
				  collapsed:: true
					- 当使用InnoDB存储引擎的表的某些记录加S锁，需要先在表级别添加一个IS锁。
					- 当使用InnoDB存储引擎的表的某些记录加X锁，需要先在表级别添加一个IX锁。
				- 表级别的AUTO-INC锁
				  collapsed:: true
					- 背景：在我们使用MySQL的时候，一般会给表的主键id添加`AUTO_INCREMENT`属性，表示该字段的值是自动递增的。
					- 作用：保证自增字段值的有序插入。
					- MySQL针对`AUTO_INCREMENT`修饰的列进行递增赋值的实现方式有两个
					  collapsed:: true
						- 一采用AUTO-INC锁
						  collapsed:: true
							- 原理
							  collapsed:: true
								- 在执行该插入语句的时候会先加一个AUTO-INC锁
								- 然后为每天插入记录标记了AUTO_INCREMENT属性的列生成递增的值
								- 执行插入操作后，释放该锁
							- 缺点：一个事务在获得该锁后，其他事务的插入语句都会被阻塞。
							- 场景：在不确定具体要插入多少条记录的时候会使用这个锁，例如`INSERT....SELECT`、`REPLACE...SELECT`或者`LOAD DATA`这种插入语句。
						- 二采用一个轻量级的锁
						  collapsed:: true
							- 原理
							  collapsed:: true
								- 在执行插入语句的时候会先加一个轻量级锁
								- 然后生成本次插入记录标记了AUTO_INCREAMENT属性的列的值
								- 然后释放轻量级锁
								- 最后执行插入
							- 优点：避免锁表，可以提升插入性能。
							- 场景：适合在执行前就可以确定要插入数据的条数。
			- InnoDB引擎中的行级锁
				- 行级锁主要有以下四种
				- 记录锁-Record Lock
				  collapsed:: true
					- 作用：仅仅是将一条记录锁上
					- 官方名称：LOCK_REC_NOT_GAP
					- 分类
					  collapsed:: true
						- 也分为S锁和X锁。
						- 两个事务针对S锁和X锁的四中组合中，只有两个事务都持有S锁是兼容的，其余情况都会被阻塞。
				- Gap Lock
				  collapsed:: true
					- 作用：解决幻读问题。
					- 原理
					  collapsed:: true
						- 它会在一条记录**之前**添加一个区间锁，阻塞新插入该区间的数据，从而防止在该条记录之前插入新的数据。
						- 如图所示，number列的值在区间(3,8)加gap锁之后是不允许插入新的记录的，`number`是这张表的主键。
						  ![gap锁.png](../assets/gap锁_1690362311128_0.png)
						- 如何阻止在表的最后一条记录之后插入新的记录
						  collapsed:: true
							- 这里涉及到数据库表的两条伪记录，一个是Infimum，表示该页面中最小的记录，一个是Supermum，表示该页面最大的记录。
							- 在最后一行数据之后加gap锁，保证最后一条数据之后不允许再插入新的记录。
							- 如图所示，number列的值在区间(20,正无穷)加gap锁，不允许插入新的记录。
							  ![Supermum加锁.png](../assets/Supermum加锁_1690364082256_0.png)
					- Next-Key Lock
					  collapsed:: true
						- 是gap锁的一种特殊的锁。
						- 作用：不仅会锁住**当前这行记录**，还会阻止其他事务在这条记录之前的**间隙插入新的记录**。也就是说他同时具备Record Lock和Gap Lock的功能。
				- 插入意向锁-Insert Intention Lock
				  collapsed:: true
					- 官方命名：LOCK_INSERT_INTENTION
					- 作用：一个事务在插入一条记录时，需要判断插入位置是否存在gap锁。若存在的话，插入操作就需要等待，并于此同时需要生成一个锁结构，表明自己想要在某个间隙插入新的记录，这个生成的锁结构，我们称为意向插入锁。
					- 工作原理：假设三个事务T1、T2、T3，T1持有gap锁，那么T2和T3就需要等待并生成意向插入锁。当T1释放gap锁之后，T2和T3就会获得插入意向锁，他两之间不会阻塞，可以同时获得插入意向锁。
				- 隐式锁
				  collapsed:: true
					- 工作原理
					  collapsed:: true
						- 对于聚簇索引的记录
						  id:: 64c20048-f871-42a3-afc1-e88fc24f0053
						  collapsed:: true
							- 对于聚簇索引的记录来讲有一个隐藏的tx_id（事务id），该事务id记录着修改这条记录**最后修改记录的事务id，值得注意的是这里的修改记录，包含SELECT查询**。
							- 如果有新的事物想要获取该记录的S锁或是X锁，首先看判断记录的隐藏列tx_id是否是当前活跃事务的id。
							- 如果**不是**的话说明这个事务已经提交了，可以正常读取。
							- 如果**是**说明这个事务还没有提交，所以给当前活跃的事务生成一个X锁的索结构，锁的is_waiting属性为false，给自己也创建一个锁结构，该锁的is_waiting属性为true，自己这个事务进入等待状态。
						- 对于二级索引的记录
						  collapsed:: true
							- 二级索引记录没有隐藏的tx_id隐藏列，但二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性，该属性代表**对该页面做改动的最大的事务id**。
							- 如果PAGE_MAX_TRX_ID属性值小于当前最小活跃事务的id，那说明事务已经提交了，可以正常读取。
							- 否则就需要找到二级索引记录，通过回表操作找到容对应的聚簇索引记录，然后重复 ((64c20048-f871-42a3-afc1-e88fc24f0053))的步骤。
					- 作用
					  collapsed:: true
						- 隐式锁起到的延迟加锁的效果，如果当前事务与该记录操作的事务没有冲突，那就不用加锁了。这个动作对用户来讲是透明的。
			- 其他存储引擎中的锁
			  collapsed:: true
				- MyIASM、MEMORY、MERGE存储引擎来说，只支持表级别的锁，不支持事务。
				- MyIASM支持并发插入的特性，可以在读取MyIASM表的同时插入记录，从而提高性能。
				-
			- InnoDB锁的内存结构
			  collapsed:: true
				- 对一条记录加锁的本质就是在内存中创建了一个锁结构与之关联。
				- 锁的内存结构
				  collapsed:: true
					- 锁所在的事务信息
					- 索引信息
					- 表锁/行锁信息
					  collapsed:: true
						- Space ID：记录所在的表空间
						- Page Number：记录所在的页号
						- n_bits：一条记录对应一个比特，用来标识在哪些记录上加了锁，这个地方记录了这些标识的比特信息。
					- type_mode
					  collapsed:: true
						- 是一个32比特的数，结构如下图所示
						  ![type_mode的作用.png](../assets/type_mode的作用_1690452429587_0.png)
						- lock_mode
						  collapsed:: true
							- 标记锁模式，占用低4比特
							- 参数
							  collapsed:: true
								- LOCK_IS：意向共享锁
								- LOCK_IX：意向独占锁
								- LOCK_S：共享锁
								- LOCK_X：独占锁
								- LOCK_AUTO_INC：AUTO-INC锁
						- lock_type
						  collapsed:: true
							- 标锁类型，占用4比特
							- 参数
							  collapsed:: true
								- LOCK_TABLE：表示表锁
								- LOCK_REC：表示行锁
						- rec_lock_type
						  collapsed:: true
							- 标记行锁的具体类型，占用24比特
							- 参数
							  collapsed:: true
								- LOCK_ORDINARY：表示next-key锁
								- LOCK_GAP：表示gap锁。
								- LOCK_REC_NOT_GAP：表示记录锁
								- LOCK_INSERT_INTENTION：表示插入意向锁
								- 其他类型
		- 4.语句加锁分析
		  collapsed:: true
			- 普通的SELECT语句
			  collapsed:: true
				- 在**读未提交**情况下
				  collapsed:: true
					- 不加锁，直接读取记录的版本。
					- 可能会出现脏读、不可重复读、幻读的情况。
				- 在**读提交**情况下
				  collapsed:: true
					- 不加锁，**每次**执行SELECT语句都会生成一个ReadView。
					- 由于每次都是新的一个ReadView，就不会读取到其他事务提交的数据，**不存在脏读**。
					- 但是由于每次都是新的一个ReadView，第一次读取的数据和第二次读取的数据就是两个不同的ReadView，**所以存在不可重复读和幻读的问题**。
				- 在**可重复读**情况下
				  collapsed:: true
					- 不加锁，只在第一次执行SELECT语句的时候生成一个ReadView
					- 由于只在第一次生成一个ReadView，也就是说当前事物只能看到他自己事务SELECT之前所能看见的数据，之后其他事务的动作都看不见，所以不存在脏读、不可重复读和幻读（一般意义上来说）的情况。
					- **可重复读情况下也是存在幻读的情况的**
					  collapsed:: true
						- 情况描述
						  collapsed:: true
							- 假设事务A使用聚簇索引去查询SELECT一条数据，这条数据数据库就没有。
							- 接着B事务插入了一条新的数据，
							- 事务A再去查询SELECT一条数据，此时查到了。
						- 原因分析
						  collapsed:: true
							- 首先事务A在可重复读情况下查询一条数据，此时会生成一个新的ReadView，这个ReadView里压根没那条数据。
							- 接着B事务插入了一条新的数据，此新数据的聚簇索引trx_id隐藏列就会记录事务A的事务id。
							- 接着A事务再次查询就可以看到这条记录了。
				- 在**串行化**情况下
				  collapsed:: true
					- 两种情况，第一种系统变量`autocommit=0`
					  collapsed:: true
						- 普通的`select`语句就会转换为`select ... lock in share mode`语句去执行。
					- 第二种情况`autocommit=1`
					  collapsed:: true
						- 由于会自动提交事务，所以一个事务里面只有一条select语句，所以不会出现脏读、不可重复读和幻读的情况。
			- 锁定读的语句
			  collapsed:: true
				- 锁定读的语句有四个
				  collapsed:: true
					- select ... lock in share mode
					- select ... for update
					- update
					- delete
				- 两个概念
				  collapsed:: true
					- 匹配模式
					  collapsed:: true
						- 匹配模式的执行步骤：使用索引查询时，查询优化器会生成一个若干个扫描区间，针对每一个扫描区间，可以迅速定位到第一条记录，然后沿着第一条记录所在的单链表访问该扫描区间的其他记录，直到某条记录不在扫描区间内为止。
						- 如何判断当前查询的匹配模式是否为精准匹配
						  collapsed:: true
							- 这个取决于扫描区间的可控范围，如果查询条件是精确的，例如采用`=`操作符，我们就认为当前查询的匹配模式是精准匹配。如果查询条件不是精准的，例如采用`<`、`<`等操作符，我们认为当前查询的匹配模式不是精准的。
					- 唯一性搜索
					  collapsed:: true
						- 定义：在扫描某个扫描区间之前，就能够确定该扫描区间最多只包含一条记录。比如包含主键查询、例如`id=1`或者是唯一索引这种情况的。
						- 如何判断扫描区间最多只包含一条记录，需满足如下条件
						  collapsed:: true
							- 匹配模式是精准匹配。
							- 使用的索引是主键或唯一二级索引。
							- 若搜索条件是唯一二级索引，则搜索条件不能为`索引列 IS NULL`，原因是唯一索引列可以存储多个NULL值的记录。
				- 锁的释放：一般锁在事务提交或是回滚时才会释放。但是在隔离级别不大于**READ COMMITTED**的某些情况下也会提前将一些不符合条件的记录上的锁释放掉。
				- 锁定读操作的一般步骤
				  collapsed:: true
					- 步骤一：快速在B+数中定位改扫描区间的第一条记录，将该记录作为当前记录。
					- 步骤二：为当前记录加锁
					  collapsed:: true
						- 针对隔离级别不大于**READ COMMITTED**时，会为当前记录加**正经记录锁**。
						- 针对隔离级别不小于**REPEATABLE READ**时，会为当前记录加**next key锁**。
					- 步骤三：判断索引条件下推的条件是否成立
					  collapsed:: true
						- 什么事索引条件下推
						  collapsed:: true
							- 将查询中与索引有关的搜索条件下推到存储引擎中判断，而不是返回到server层再判断。
						- 目的
						  collapsed:: true
							- 减少回表次数，也就是减少读取完整聚簇索引记录的次数，减少IO操作。
						- 判断条件
						  collapsed:: true
							- 1.该步骤只适用于二级索引，若为聚簇索引则不成立。
							- 2.该步骤只适用于SELECT语句，不适用于UPDATE、DELETE语句。
							- 3.判断当前记录是否符合扫描区间的边界条件，若不符合则直接返回server层“查询完毕”。
							- 若符合上述条件则执行步骤四。否则直接读取单链表的下一条记录，将新的记录作为当前记录，会跳到步骤二执行。
						- **值得注意**的是当前步骤不释放锁。
					- 步骤四：执行回表操作
					  collapsed:: true
						- 若读取的二级索引记录，则需要回表操作。
						- 若获取到的是聚簇索引记录，则给该聚簇索引加**正经记录锁**。
					- 步骤五：判断边界条件是否成立
					  collapsed:: true
						- 判断当前记录是否符合扫描区间的边界条件，若符合则继续执行。
						- 否则
						  collapsed:: true
							- 在隔离级别不大于**READ COMMITTED**时，释放掉该记录上的锁，并返回server层“查询完毕”。
							- 在隔离级别不小于**REPEATABLE READ**时，不释放该记录上的锁。
					- 步骤六：server层判断其余搜索条件是否成立
					  collapsed:: true
						- 判断其他搜索条件是否成立，若成立，将该记录发送给客户端。
						- 否则
						  collapsed:: true
							- 在隔离级别不大于**READ COMMITTED**时，释放掉该记录上的锁。
							- 在隔离级别不小于**REPEATABLE READ**时，不释放该记录上的锁。
					- 步骤七：获取当前记录所在单向链表的下一条记录，将其作为新的当前记录，回跳执行步骤二。
- 问题
  collapsed:: true
	- MySQL中text类型的存储和检索
	- MySQL中decimal类型的使用
- 面经
	- [这些年背过的面试题 —— MySQL篇](https://mp.weixin.qq.com/template/article/1708312042/index.html)