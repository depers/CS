- 装饰器模式
  collapsed:: true
	- 使用场景：指能够在一个类的基础上增加一个装饰类（也可以叫包装类），并在装饰类中增加一些新的特性和功能。这样，通过对原有类的包装，就可以在不改变原有类的情况下为原有类增加更多的功能。
	- 类型：结构性
	- 实现接口
		- 接口+接口实现类+装饰器类
		- 抽象类+抽象类子类+装饰器类
- 单例模式
  collapsed:: true
	- 使用场景：想确保任何情况下都绝对只有一个实例。
	- 类型：创建型
- 代理模式
  collapsed:: true
	- 使用场景
	  collapsed:: true
		- 类似于中介，不会将被代理类直接暴露出来，可以通过代理类间接的使用被代理类的功能。
		- 通过代理类可以对被代理类的方法进行增强，比如统计方法调用耗时、方法调用前后添加日志等功能
	- 类型：结构型
	- 分类
	  collapsed:: true
		- 静态代理
		- 动态代理
		  collapsed:: true
			- 对于基于反射的动态代理而言，有一个必需的条件：被代理的对象必须有一个父接口。
- 模板模式
  collapsed:: true
	- 使用场景：通过抽象类定义方法调用的顺序和规则，具体的方法实现则交给子类去实现。
	- 类型：行为型
- 适配器模式
  collapsed:: true
	- 使用场景
		- 将多个类的不同功能的方法，整合到统一的方法中，能够使得原本不兼容的类可以一起工作。
		- 如果被适配的类可以修改，就直接修改被适配的类；如果不能修改，可以通过适配器模式进行适配。
	- 构成
	  collapsed:: true
		- 被适配的类
		- 适配器类，需要实现目标类的方法
		- 目标类（接口），规定了适配器类需要实现的方法
	- 分类
	  collapsed:: true
		- 类适配器模式
		  collapsed:: true
			- **适配器类**通过继承**被适配的类**并实现**目标类**，实现适配。
		- 对象适配器模式
		  collapsed:: true
			- **适配器类**实现了**目标类**，并实例化**被适配的类对象**，实现适配。
		- 方法适配器
		  collapsed:: true
			- 通常是指相同功能但由于输入参数的不同被划分为几个方法，其中有一个是核心方法，其余几个方法通过补全输入参数的做法调用核心方法。
			- 这种方式在框架代码中比较常见。
	- 类型：结构型