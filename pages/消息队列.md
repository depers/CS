- RabbitMQ
	- 工作模式
	  collapsed:: true
		- 简单模式
			- 特征：一个生产者对应一个消费者
		- 工作队列模式
		  collapsed:: true
			- 特征：与入门程序的`简单模式`相比，多了一个或一些消费端，多个消费端共同消费同一个队列 中的消息。
			- 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。
			- 关键点
				- 循环调度：rabbitmq会将消息不断地发送给接收方。
				- 消息确认：接收方异常如果没有确认消费消息，超过交付时间，rabbitmq就会将该消息发送另一个接受者。
				- 消息持久化
					- 发送方在发送时要将消息持久化，避免rabbitmq崩溃或退出时消息丢失。值得注意的是已经创建的队列不允许修改是否持久化参数。
					- rabbitmq只是将消息保存到了缓存中，持久性并不强，简单的任务队列是够用的。如果要保证强持久性，需要使用**发布者确认**。
				- 公平调度
					- rabbitmq默认是将消息平均的分配给消费者Round-Robin，也就是，并不考虑消费者尚未确认的消息数量。
					- 可以通过prefetchCount=1，告诉rabbitmq在一个工作消费者确认一条消息前，不会再给他发消息。
		- 发布/订阅模式
			- 特征：
				- 1、同时向多个消费者发送消息
				- 2、每个消费者监听自己的队列。
				- 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。
			- 角色
			  ![发布订阅模式.png](../assets/发布订阅模式_1706260123797_0.png)
			- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）
			- C：消费者，消息的接受者，会一直等待消息到来。
			- Queue：消息队列，接收消息、缓存消息。
			- Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange的类型。Exchange有常见以下3种类型：
				- Fanout：广播，将消息交给所有绑定到交换机的队列上
				- Direct：定向，把消息交给符合指定routing key 的队列
				- Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
				- Header：根据发送消息内容中的headers属性进行匹配，性能差，一般不使用
		- 路由模式
			- 特征
				- 1、选择性地接收信息，把消息交给符合指定routing key 的队列。
				- 2、Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。
			- 角色
			  ![路由模式.png](../assets/路由模式_1706585063905_0.png)
		- 通配符模式
			- 特征
				- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用`通配符`。Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`。
				- 相比于路由模式，通配符模式可以让一个队列接收多种不同的消息，或者说RoutingKey可以接收多个生产者的消息。而不是像路由模式一样只能接收固定RoutingKey生产者的消息。
			- 匹配规则
				- `#` ：匹配一个或多个词
				- `*` ：只能匹配1个词
			- 角色
			  ![通配符模式.png](../assets/通配符模式_1706602716173_0.png)
		- 远程过程调用（RPC）模式
			- 特征
				- 如果我们需要在远程计算机上运行一个耗时计算并等待结果，我们可以利用消息队列方便的实现一个rpc系统。
			- 角色
			  ![rpc模式.png](../assets/rpc模式_1706602863437_0.png)
				- client
				- server
				- rpc_queue：保存客户端的请求信息
				- reply_to：保存服务器端的响应信息
			- 如何处理服务器的的响应
				- 通过reply_to回调队列将消息返回给客户端。
			- 如何准确的将响应返回到特定的客户端上
				- 放在回调队列上的响应，客户端如何判断这个响应是属于哪个请求的。这里我们就要提到AMQP协议消息附带的correlationId属性，我们通过在客户端声明这个属性，告诉服务端这个参数，在服务端处理后，这个参数就会发送到指定的客户端上。
		- 发布者确认
			- 目的：使用发布者确认来确保发布的消息已安全到达服务器被处理。
			- 策略
				- 单独发布消息
					- 单独发布消息，同步等待确认：简单，但吞吐量非常有限。
					- 消息发送之后，调用`Channel#waitForConfirmsOrDie(long)`方法等待被消费者确认，如果被消费了，客户端会收到异步确认，这个方法就会返回。如果消息在超时时间内没有得到确认或者被拒绝（意味着代理由于某种原因无法处理它），该方法将抛出异常。异常的处理通常包括记录错误消息或重试发送消息。
					- 主要缺点：它会显着减慢发布速度，因为消息的确认会阻止所有后续消息的发布。这种方法不会提供每秒超过数百条已发布消息的吞吐量。
				- 批量发布消息
					- 批量发布消息，批量同步等待确认：简单，吞吐量合理，但很难推断何时出现问题。
				- 异步处理发布者确认
					- 异步处理：最好的性能和资源利用，在出错的情况下很好的控制，但可以参与正确的实现。
		- 参考文章
			- [RabbitMQ教程](https://juejin.cn/post/7071589818886520869#heading-48)
			- [消息队列学习 | 基础](https://www.sulvblog.cn/posts/tech/message_queue_foundation/)
	- 按我的理解RoutingKey是邮件发送人填写的收件人地址，BindingKey是邮件收件人的地址
	- AMQP协议的模型架构：生产者将消息发送给交换器，交换器和队列绑定。当生产者发送消息时所携带的 RoutingKey 与绑定时 BindingKey 匹配时，消息即被存入相应的队列之中，消费者可以订阅相应的队列来获取消息。
	- 连接RabbitMQ
		- Connection就是一个TCP连接，通过连接来创建**信道（Channel）**，多个信道可以复用一个Connection。
		- Connection 可以用来创建**多个 Channel 实例**，但是 Channel 实例**不能在线程问共享**，应用程序应该为每一个线程开辟一个 Channel 。
		- 每个 Channel 都拥有自己独立的线程。
	- 使用交换机和队列
		- 通过`channel.exchangeDeclare()`方法创建交换机，这里具体参数说明参考《RabbitMQ实战指南》3.2.1节。
		- 通过`channel.queueDeclare(name, durable, autoDelete, exclusive, noWait, args)`方法创建队列
			- `name`：队列名字。
			- `durable`：是否持久化，队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库。
			- `autoDelete`：是否自动删除队列，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除。
			- `exclusive`：是否排外的，有两个作用，一：**当连接关闭时connection.close()该队列是否会自动删除**；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常：`com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method<channel.close>(reply-code=405, reply-text=RESOURCE_LOCKED - cannot obtain exclusive access to locked queue 'queue_name' in vhost '/', class-id=50, method-id=20)`，**一般等于true的话用于一个队列只能有一个消费者来消费的场景**。
			- `args`：相关参数，目前一般为null。
		- 通过`channel.queueBind()`方法将交换机和队列进行绑定
		- 通过`channel.exchangeBind()`方法将交换机和交换机进行绑定，交换机也可以看做是一个队列，消息也可以从一个交换机到另一个交换机
	- 发送消息
		- 通过`channel.basicPublish()`发送消息
	- 消费消息
		- 消费模式有两种：推模式和拉模式
		- 推模式，如果要实现高吞吐量建议使用这种模式。
		- 拉模式，如果只想从队列获得单条消息而不是持续订阅建议使用这种。
		- 参考文章：
			- [推或拉？ rabbitMQ 消费模式该如何选择](https://developer.aliyun.com/article/1279784)
			- 基于推和拉两种方式消费RabbitMQ消息
	- 消费端的确认和拒绝
		- 作用：采用消息确认机制，消费者就有足够的时间去消费消息，不会因消息消费过程中因消费者进程挂掉导致的消息丢失问题。
		- 原理：RabbitMQ将消息投递给消费者之后，消费者如果一直没有返回确认的话，RabbitMQ就会一直等消费者处理。如果消费者断开了连接，RabbitMQ就会将这条消息重新投递。
		- 消息是否重新投递给消费者的唯一依据：消费者连接是否断开
	- 关闭连接
		- Connection和Channel的生命周期
		- 监听器
		- 获取关闭原因
	- 生产者发送消息到交换器的逻辑
		- 背景：如果生产者生产消息，消息发送不到消息者那里该怎么办
		- `mandatory`参数（`channel.basicPublish`方法参数）
			- 作用：用于控制一个消息到达交换机器时，**交换器根据自身类型和路由键找不到一个符合条件的队列**，若该参数设置为true就将该消息返回给生产者，如果为false，就将消息丢弃。
			- 发送时没有必要设置mandotory，因为Spring Boot和RabbitMQ的集成后，我发现即便是exchage找不到对应的queue后，生产端不仅在rabbitTemplate的ReturnsCallback中做了返回，而且还在ConfirmCallback中做了ack的确认，所以这里其实作用不大，这就需要我们在项目启动的时候做好exchange、queue和binding的创建。
		- `immediate`参数
			- 作用：如果**交换器将消息路由到队列时发现队列上不存在任何消费者**，如果该参数为true，该消息不会存入到队列而会返回给生产者。
			- 这个参数在RabbitMQ3.0被废弃。
		- 备份交换机
			- 背景：功能和mandatory参数类似，都是消息和交换机无法匹配到符合条件的队列时所做的逻辑处理。不同的是mandatory的处理逻辑相对比较麻烦，我们可以直接创建一个新的交换机，用来将之前不符合条件的消息放置到备份交换机的队列中。
	- 设置过期时间
		- 为队列设置过期时间
		- 为每条消息设置过期时间
	- 死信队列
		- 消息变为死信的情况
			- 消息被拒绝
			- 消息过期
			- 队列达到最大长度
		- DLX，Dead-Letter-Exchange，死信交换器
			- 死信消息会从原队列被转发到死信交换器上，最后存到死信队列中。
		- 死信队列
			- 是指绑定死信交换机队列被称为死信队列。
			- 通过设置`x-dead-letter-exchange`属性为队列指定消息死信时需要转发的死信交换机
			- 通过设置`x-dead-letter-routing-key`属性为队列指定消息死信时死信交换机绑定队列的routing key。这个可以简称DLK。
		- 弥补immediate参数
			- 采用**DLX**+**消息的TTL设置为0**来弥补这个功能的废弃。
	- 延时队列
		- 设置了`x-message-tll`属性的队列为延时队列，如果放置到这个队列的消息到有效时间之后就会被自动转发到死信交换机DLX。
		- Rabbit没有直接支持延时队列，但是可以通过DLX死信队列交换器和TTL属性模拟出延时队列
		- 具体使用：假设延时时间分为多个等级1s，10s，30s，1min，分别为这些消息设置不同的路由键、不同的队列，不同的死信交换机，不同的死信队列。
	- 优先级队列
		- 设置了`x-max-priority`属性的队列为优先级队列，在消费者消费的速度小于生产者生产的速度时，也就说会有消息的堆积，此时高优先级的消息可以优先被消费。
	- RPC实现
		- BasicProperties的两个属性
			- `replyTo`：回调队列
			- `correlationId`：用于关联请求和调用RPC服务之后的响应。不然服务端无法区分该响应返回给那个请求。
	- 持久化
		- 交换机持久化
			- 在声明交换机时将durable置为true实现
			- 丢失的信息：保存交换机元数据不会丢失，对于一个长期使用的交换机建议设置为true
		- 队列持久化
			- 在声明队列时将durable置为true实现
			- 丢失的信息：保存队列的元数据和存储在队列中的消息。
			- 值得注意的是队列的持久化并不能保证消息的持久化。
		- 消息持久化
			- 在发送消息时`channel.basicPublish()`有一个`BasicProperties`属性，这个类有一个`deliveryMode`属性，设置为`2`，表示进行消息的持久化。
		- 值得注意的是
			- 将所有消息设置持久化，需要将消息写入磁盘，会降低吞吐量。对于可靠性不高的消息，可以不做持久化。
			- 消费者手动确认消息，保证消费者接收到消息并正确处理后进行手动确认，避免消息因消费者处理异常导致消息丢失。
			- 关键业务队列要设置为镜像队列。
			- 消息生产者引入事务机制和发送方确认机制，保证消息的可靠性。
	- 生产者确认
		- 背景：生产者为了保证发送的消息能够正确的到达broker。
		- 方法
			- 事务机制
				- 同步阻塞
				- 严重减低RabbitMQ消息的吞吐量。
			- 发送方确认机制
				- 同步确认
				- 批量确认
				- 异步确认
		- RabbitMQ返回给生产者的确认信息
			- `deliveryTag`：确认消息的序号
			- `multiple`：这个序号之前的所有消息都得到了处理
		- 注意要点
			- 事务机制和发送方确认机制不能共存。
			- 事务机制和发送方确认机制保证的是消息从发送方到交换机之前的可靠投递，并不保证交换机到队列的可靠性投递，所以这里我们需要借助`mandatory`参数或是备份交换机一起来保证消息的可靠性传输。
	- Spring Boot中使用RabbitMQ
		- 配置文件
			- 生产者
			- 消费者
		- 队列、交换机和绑定关系的声明
			- RabbitAdmin
				- RabbitAdmin 是 Spring-AMQP 中的核心基础组件，是我们在 Spring 中对 RabbitMQ 进行初始化的必须组件，其提供了 RabbitMQ 中声明交换机、声明队列、绑定交换机和队列，以及绑定路由 Key 等其他 API ，RabbitAdmin 正式由此得名。
			- 手动进行bean声明
		- 设置监听器类型
		  background-color:: red
			- simple
			- direct
		- 死信队列这块的处理
		  background-color:: red
		- 消费端的消息什么情况下需要重试
		  background-color:: red
		- 消息消费如何保证顺序性
		  background-color:: red
		- 参考文章
			- [mandatory、publisher-confirms、publisher-return属性区别](https://blog.csdn.net/yaomingyang/article/details/106857104)
			- [SpringBoot接入消息中间件RabbitMQ](https://www.cnblogs.com/xfeiyun/p/16185655.html)
			- [SpringBoot AMQP](https://pencil.lynchj.com/2022/07/07/springboot-amqp/)
			- [优雅封装RabbitMQ实现动态队列、动态生产者，动态消费者绑定](https://juejin.cn/post/7223325947339931707#heading-2)
	- VirtualHost
		- 我的理解virtual-host类似于一个命名空间的东西，他就跟普通的物理 RabbitMQ 一样，不同的 vhost 能够提供逻辑上的分离，确保不同的应用消息队列能够安全独立运行。
		- 参考文章：[RabbitMQ 中的 VirtualHost 该如何理解](https://juejin.cn/post/7034476248332140575?searchId=20240423135624B080998E451F93F6977F)
	- 参考博文
		- [RabbitMQ最佳实践](https://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html)
		- [RabbitMQ消息丢失的场景，如何保证消息不丢失？（详细讲解，一文看懂）](https://cloud.tencent.com/developer/article/2342719)
	-