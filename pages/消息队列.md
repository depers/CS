- RabbitMQ
	- 简单模式
	  collapsed:: true
		- 特征：一个生产者对应一个消费者
	- 工作队列模式
	  collapsed:: true
		- 特征：与入门程序的`简单模式`相比，多了一个或一些消费端，多个消费端共同消费同一个队列 中的消息。
		- 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。
		- 关键点
		  collapsed:: true
			- 循环调度：rabbitmq会将消息不断地发送给接收方。
			- 消息确认：接收方异常如果没有确认消费消息，超过交付时间，rabbitmq就会将该消息发送另一个接受者。
			- 消息持久化
				- 发送方在发送时要将消息持久化，避免rabbitmq崩溃或退出时消息丢失。值得注意的是已经创建的队列不允许修改是否持久化参数。
				- rabbitmq只是将消息保存到了缓存中，持久性并不强，简单的任务队列是够用的。如果要保证强持久性，需要使用**发布者确认**。
			- 公平调度
			  collapsed:: true
				- rabbitmq默认是将消息平均的分配给消费者，并不考虑消费者尚未确认的消息数量。
				- 可以通过prefetchCount=1，告诉rabbitmq在一个工作消费者确认一条消息前，不会再给他发消息。
	- 发布/订阅模式
	  collapsed:: true
		- 特征：
		  collapsed:: true
			- 1、同时向多个消费者发送消息
			- 2、每个消费者监听自己的队列。
			- 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。
		- 角色
		  ![发布订阅模式.png](../assets/发布订阅模式_1706260123797_0.png)
		- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）
		- C：消费者，消息的接受者，会一直等待消息到来。
		- Queue：消息队列，接收消息、缓存消息。
		- Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange的类型。Exchange有常见以下3种类型：
		  collapsed:: true
			- Fanout：广播，将消息交给所有绑定到交换机的队列
			- Direct：定向，把消息交给符合指定routing key 的队列
			- Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
	- 路由模式
	  collapsed:: true
		- 特征
		  collapsed:: true
			- 1、选择性地接收信息，把消息交给符合指定routing key 的队列。
			- 2、Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。
		- 角色
		  ![路由模式.png](../assets/路由模式_1706585063905_0.png)
	- 通配符模式
	  collapsed:: true
		- 特征
		  collapsed:: true
			- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用`通配符`。Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`。
			- 相比于路由模式，通配符模式可以让一个队列接收多种不同的消息，或者说RoutingKey可以接收多个生产者的消息。而不是像路由模式一样只能接收固定RoutingKey生产者的消息。
		- 匹配规则
		  collapsed:: true
			- `#` ：匹配一个或多个词
			- `*` ：只能匹配1个词
		- 角色
		  ![通配符模式.png](../assets/通配符模式_1706602716173_0.png)
	- 远程过程调用（RPC）模式
	  collapsed:: true
		- 特征
		  collapsed:: true
			- 如果我们需要在远程计算机上运行一个耗时计算并等待结果，我们可以利用消息队列方便的实现一个rpc系统。
		- 角色
		  collapsed:: true
		  ![rpc模式.png](../assets/rpc模式_1706602863437_0.png)
			- client
			- server
			- rpc_queue：保存客户端的请求信息
			- reply_to：保存服务器端的响应信息
		- 如何处理服务器的的响应
		  collapsed:: true
			- 通过reply_to回调队列将消息返回给客户端。
		- 如何准确的将响应返回到特定的客户端上
		  collapsed:: true
			- 放在回调队列上的响应，客户端如何判断这个响应是属于哪个请求的。这里我们就要提到AMQP协议消息附带的correlationId属性，我们通过在客户端声明这个属性，告诉服务端这个参数，在服务端处理后，这个参数就会发送到指定的客户端上。
	- 发布者确认
	  collapsed:: true
		- 目的：使用发布者确认来确保发布的消息已安全到达服务器被处理。
		- 策略
			- 单独发布消息
			  collapsed:: true
				- 单独发布消息，同步等待确认：简单，但吞吐量非常有限。
				- 消息发送之后，调用`Channel#waitForConfirmsOrDie(long)`方法等待被消费者确认，如果被消费了，客户端会收到异步确认，这个方法就会返回。如果消息在超时时间内没有得到确认或者被拒绝（意味着代理由于某种原因无法处理它），该方法将抛出异常。异常的处理通常包括记录错误消息或重试发送消息。
				- 主要缺点：它会显着减慢发布速度，因为消息的确认会阻止所有后续消息的发布。这种方法不会提供每秒超过数百条已发布消息的吞吐量。
			- 批量发布消息
			  collapsed:: true
				- 批量发布消息，批量同步等待确认：简单，吞吐量合理，但很难推断何时出现问题。
			- 异步处理发布者确认
			  collapsed:: true
				- 异步处理：最好的性能和资源利用，在出错的情况下很好的控制，但可以参与正确的实现。
	- 参考文章
	  collapsed:: true
		- [RabbitMQ教程](https://juejin.cn/post/7071589818886520869#heading-48)
		- [消息队列学习 | 基础](https://www.sulvblog.cn/posts/tech/message_queue_foundation/)