- RabbitMQ
	- 工作模式
	  collapsed:: true
		- 简单模式
		  collapsed:: true
			- 特征：一个生产者对应一个消费者
		- 工作队列模式
		  collapsed:: true
			- 特征：与入门程序的`简单模式`相比，多了一个或一些消费端，多个消费端共同消费同一个队列 中的消息。
			- 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。
			- 关键点
			  collapsed:: true
				- 循环调度：rabbitmq会将消息不断地发送给接收方。
				- 消息确认：接收方异常如果没有确认消费消息，超过交付时间，rabbitmq就会将该消息发送另一个接受者。
				- 消息持久化
				  collapsed:: true
					- 发送方在发送时要将消息持久化，避免rabbitmq崩溃或退出时消息丢失。值得注意的是已经创建的队列不允许修改是否持久化参数。
					- rabbitmq只是将消息保存到了缓存中，持久性并不强，简单的任务队列是够用的。如果要保证强持久性，需要使用**发布者确认**。
				- 公平调度
				  collapsed:: true
					- rabbitmq默认是将消息平均的分配给消费者Round-Robin，也就是，并不考虑消费者尚未确认的消息数量。
					- 可以通过prefetchCount=1，告诉rabbitmq在一个工作消费者确认一条消息前，不会再给他发消息。
		- 发布/订阅模式
		  collapsed:: true
			- 特征：
			  collapsed:: true
				- 1、同时向多个消费者发送消息
				- 2、每个消费者监听自己的队列。
				- 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。
			- 角色
			  ![发布订阅模式.png](../assets/发布订阅模式_1706260123797_0.png)
			- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）
			- C：消费者，消息的接受者，会一直等待消息到来。
			- Queue：消息队列，接收消息、缓存消息。
			- Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange的类型。Exchange有常见以下3种类型：
			  collapsed:: true
				- Fanout：广播，将消息交给所有绑定到交换机的队列上
				- Direct：定向，把消息交给符合指定routing key 的队列
				- Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
				- Header：根据发送消息内容中的headers属性进行匹配，性能差，一般不使用
		- 路由模式
		  collapsed:: true
			- 特征
			  collapsed:: true
				- 1、选择性地接收信息，把消息交给符合指定routing key 的队列。
				- 2、Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。
			- 角色
			  ![路由模式.png](../assets/路由模式_1706585063905_0.png)
		- 通配符模式
		  collapsed:: true
			- 特征
			  collapsed:: true
				- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用`通配符`。Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`。
				- 相比于路由模式，通配符模式可以让一个队列接收多种不同的消息，或者说RoutingKey可以接收多个生产者的消息。而不是像路由模式一样只能接收固定RoutingKey生产者的消息。
			- 匹配规则
			  collapsed:: true
				- `#` ：匹配一个或多个词
				- `*` ：只能匹配1个词
			- 角色
			  ![通配符模式.png](../assets/通配符模式_1706602716173_0.png)
		- 远程过程调用（RPC）模式
		  collapsed:: true
			- 特征
			  collapsed:: true
				- 如果我们需要在远程计算机上运行一个耗时计算并等待结果，我们可以利用消息队列方便的实现一个rpc系统。
			- 角色
			  collapsed:: true
			  ![rpc模式.png](../assets/rpc模式_1706602863437_0.png)
				- client
				- server
				- rpc_queue：保存客户端的请求信息
				- reply_to：保存服务器端的响应信息
			- 如何处理服务器的的响应
			  collapsed:: true
				- 通过reply_to回调队列将消息返回给客户端。
			- 如何准确的将响应返回到特定的客户端上
			  collapsed:: true
				- 放在回调队列上的响应，客户端如何判断这个响应是属于哪个请求的。这里我们就要提到AMQP协议消息附带的correlationId属性，我们通过在客户端声明这个属性，告诉服务端这个参数，在服务端处理后，这个参数就会发送到指定的客户端上。
		- 发布者确认
		  collapsed:: true
			- 目的：使用发布者确认来确保发布的消息已安全到达服务器被处理。
			- 策略
			  collapsed:: true
				- 单独发布消息
				  collapsed:: true
					- 单独发布消息，同步等待确认：简单，但吞吐量非常有限。
					- 消息发送之后，调用`Channel#waitForConfirmsOrDie(long)`方法等待被消费者确认，如果被消费了，客户端会收到异步确认，这个方法就会返回。如果消息在超时时间内没有得到确认或者被拒绝（意味着代理由于某种原因无法处理它），该方法将抛出异常。异常的处理通常包括记录错误消息或重试发送消息。
					- 主要缺点：它会显着减慢发布速度，因为消息的确认会阻止所有后续消息的发布。这种方法不会提供每秒超过数百条已发布消息的吞吐量。
				- 批量发布消息
				  collapsed:: true
					- 批量发布消息，批量同步等待确认：简单，吞吐量合理，但很难推断何时出现问题。
				- 异步处理发布者确认
				  collapsed:: true
					- 异步处理：最好的性能和资源利用，在出错的情况下很好的控制，但可以参与正确的实现。
		- 参考文章
		  collapsed:: true
			- [RabbitMQ教程](https://juejin.cn/post/7071589818886520869#heading-48)
			- [消息队列学习 | 基础](https://www.sulvblog.cn/posts/tech/message_queue_foundation/)
	- 按我的理解RoutingKey是邮件发送人填写的收件人地址，BindingKey是邮件收件人的地址
	- AMQP协议的模型架构：生产者将消息发送给交换器，交换器和队列绑定。当生产者发送消息时所携带的 RoutingKey 与绑定时 BindingKey 匹配时，消息即被存入相应的队列之中，消费者可以订阅相应的队列来获取消息。
	- 连接RabbitMQ
	  collapsed:: true
		- Connection就是一个TCP连接，通过连接来创建**信道（Channel）**，多个信道可以复用一个Connection。
		- Connection 可以用来创建**多个 Channel 实例**，但是 Channel 实例**不能在线程问共享**，应用程序应该为每一个线程开辟一个 Channel 。
		- 每个 Channel 都拥有自己独立的线程。
	- 使用交换机和队列
	  collapsed:: true
		- 通过`channel.exchangeDeclare()`方法创建交换机
		- 通过`channel.queueDeclare()`方法创建队列
		- 通过`channel.queueBind()`方法将交换机和队列进行绑定
		- 通过`channel.exchangeBind()`方法将交换机和交换机进行绑定，交换机也可以看做是一个队列，消息也可以从一个交换机到另一个交换机
	- 发送消息
	  collapsed:: true
		- 通过`channel.basicPublish()`发送消息
	- 消费消息
	  collapsed:: true
		- 消费模式有两种：推模式和拉模式
		- 推模式，如果要实现高吞吐量建议使用这种模式
		- 拉模式，如果只想从队列获得单条消息而不是持续订阅建议使用这种
	- 消费端的确认和拒绝
	  collapsed:: true
		- 作用：采用消息确认机制，消费者就有足够的时间去消费消息，不用处理消息过程中因消费者进程挂掉导致的消息丢失问题。
		- 原理：RabbitMQ将消息投递给消费者之后，消费者如果一直没有返回确认的话，RabbitMQ就会一直等消费者处理。如果消费者断开了连接，RabbitMQ就会将这条消息重新投递。
		- 消息是否重新投递给消费者的唯一依据：消费者连接是否断开
	- 关闭连接
	  collapsed:: true
		- Connection和Channel的生命周期
		- 监听器
		- 获取关闭原因
	- 生产者发送消息到交换器的逻辑
	  collapsed:: true
		- 背景：如果生产者生产消息，消息发送不到消息者那里该怎么办
		- `mandatory`参数（`channel.basicPublish`方法参数）
		  collapsed:: true
			- 作用：用于控制一个消息到达交换机器时，**交换器根据自身类型和路由键找不到一个符合条件的队列**，若该参数设置为true就将该消息返回给生产者，如果为false，就将消息丢弃。
		- `immediate`参数
		  collapsed:: true
			- 作用：如果**交换器将消息路由到队列时发现队列上不存在任何消费者**，如果该参数为true，该消息不会存入到队列而会返回给生产者。
			- 这个参数在RabbitMQ3.0被废弃。
		- 备份交换机
		  collapsed:: true
			- 背景：功能和mandatory参数类似，都是消息和交换机无法匹配到符合条件的队列时所做的逻辑处理。不同的是mandatory的处理逻辑相对比较麻烦，我们可以直接创建一个新的交换机，用来将之前不符合条件的消息放置到备份交换机的队列中。
	- 设置过期时间
	  collapsed:: true
		- 为队列设置过期时间
		- 为每条消息设置过期时间
	- 死信队列
	  collapsed:: true
		- DLX，Dead-Letter-Exchange，死信交换器
		- 消息变为死信的情况，这些消息会从原队列被转发到死信交换器上，最后存到死信队列中
		  collapsed:: true
			- 消息被拒绝
			- 消息过期
			- 队列达到最大长度
	- 延时队列
	  collapsed:: true
		- Rabbit没有直接支持延时队列，但是可以通过DLX死信队列交换器和TTL属性模拟出延时队列
		- 具体使用：假设延时时间分为多个等级1s，10s，30s，1min，分别为这些消息设置不同的路由键、不同的队列，不同的死信交换机，不同的死信队列
	- 参考博文
		- [RabbitMQ最佳实践](https://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html)
	-