- Redis
	- Jedis
		- 使用
			- 参考文章：
				- [jedis的基本使用](https://blog.csdn.net/zhang_sheng_nian/article/details/127734172)
				- [redis基于zset实现延迟队列](https://cloud.tencent.com/developer/article/2310463)
		- Jedis连接池
			- 参考文章
				- [java客户端：Jedis和Jedis连接池的基本使用和配置](https://zhuanlan.zhihu.com/p/84481313)
				- [GenericObjectPool源码分析](https://www.cnblogs.com/chenjian5/p/5149312.html)
				- [为什么建议JedisPool的maxIdle与maxActive设置成一样的数值](https://www.jianshu.com/p/1f1568627f87)
	- 数据结构
	  collapsed:: true
		- String
			- 使用场景
				- 缓存对象
				- 常规计数
				- 分布式锁
				- 共享session
			- 存储的最大容量
				- Redis 一个字符串类型的值最大可以存储512MB的数据。这是因为Redis使用了一个sds数据结构（simple dynamic string），这种数据结构在Redis中被广泛使用，可以实现高效的字符串操作，并且支持动态扩容。而sds的最大长度是2^32-1字节，也就是4GB，但在Redis中，字符串类型的值除了存储数据外，还需要存储一些元数据信息（例如长度等），所以实际上字符串类型的值能存储的最大容量是512MB。
		- List
		- Hash
		- Set
		- Zset
	- 持久化机制
	  collapsed:: true
		- RDB
			- Redis DataBase缩写快照
			- 默认的持久化方式。
			- 优点
				- 只有一个文件，方便持久化。
				- 容灾性好，一个文件可以保存到安全的磁盘。
				- 性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。
				- 相对于数据集大时，比 AOF 的启动效率更高。
			- 缺点
				- RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。
		- AOF
			- Append Only File持久化
			- 优点
				- 数据安全系数高，如果服务器发送宕机，数据丢失的少。
			- 缺点
				- AOF 文件比 RDB 文件大，且恢复速度慢。
				- 数据集大的时候，比 rdb 启动效率低。
			-
	- Redis的集群架构
	  collapsed:: true
		- 主从架构
		- 哨兵架构
			- 客户端与Redis服务器端的交互
			  collapsed:: true
				- **客户端会连接主节点**：当**客户端尝试连接到 Redis 服务器**时，它会向主节点发送连接请求。如果主节点正常运行，客户端将能够与主节点进行通信并执行各种 Redis 操作。
				- **出现异常，哨兵会将新的主节点通知给客户端**：如果主节点发生故障或不可用，哨兵节点会检测到这种情况，并触发故障转移过程。在故障转移期间，哨兵节点会选择一个新的主节点，并将其信息传播给其他哨兵节点和客户端。
				- **客户端可以通过配置来监听哨兵节点的通知**，以便及时了解主节点的变化。当主节点发生更改时，客户端可以自动重新连接到新的主节点，继续执行操作。
			- 多主从的哨兵架构
				- 需要客户端进行分片逻辑，负责将不同的数据分散到不同的节点
				- 缺点
					- 新增节点时数据迁移会造成很大工作量
					- 较少节点会造成数据的丢失
		- 集群架构
- Guava Cache
- 多级缓存的设置
	- 先打本地缓存，接着redis缓存，最后数据库
- 缓存穿透
	- **缓存穿透是指数据库和缓存都没有的数据**，每次都要经过缓存去访问数据库，大量的请求有可能导致DB宕机。
	- 应对策略
		- **使用布隆过滤器**（Bloom Filter）：布隆过滤器是一种快速判断元素是否存在的数据结构，它可以在很小的内存占用下，快速判断一个元素是否在一个集合中。将所有可能存在的数据哈希到一个足够大的位数组中，当一个请求过来时，先经过布隆过滤器判断是否存在于缓存中，如果不存在，则直接返回，避免对数据库的查询压力。
			- 存在的问题：布隆过滤器经常使用在缓存数据更新较少的场景中，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制
		- **空对象缓存**：对于确定不存在的数据，在缓存中也存储一个空对象，表示该数据不存在。当请求访问这些不存在的数据时，直接从缓存中返回空对象，避免每次请求都穿透到数据库层进行查询。
- 缓存击穿
	- **缓存击穿是指数据库有，缓存没有的热点数据**，大量请求访问这个缓存不存在的数据，最后请求打到DB可能导致DB宕机。
	- 应对策略
		- **设置热点数据的热度时间窗口**：对于热点数据，可以设置一个热度时间窗口，在这个时间窗口内，如果一个数据被频繁访问，就将其缓存时间延长，避免频繁刷新缓存导致缓存击穿。
		- **使用互斥锁或分布式锁**：在缓存失效时，只允许一个线程去查询数据库，其他线程等待查询结果。可以使用互斥锁或分布式锁来实现，确保只有一个线程能够查询数据库，其他线程等待结果，避免多个线程同时查询数据库造成数据库压力过大。
		- **缓存永不过期**：对于一些热点数据，可以将其缓存设置为永不过期，或者设置一个很长的过期时间，这样即使缓存失效，也有足够的时间来刷新缓存，避免缓存击穿。
- 缓存雪崩
	- **缓存雪崩指的是在同一时段大量的缓存键（key）同时失效**，导致大量请求打到数据库，最后请求打到DB可能导致DB宕机。
	- 应对策略
		- **使用多级缓存架构**：将缓存划分为多个层级，每个层级的缓存设置不同的过期时间。例如，将热点数据存储在近期失效的缓存层级，而将非热点数据存储在长期失效的缓存层级。这样即使某一层级的缓存失效，仍然可以从其他层级获取数据，避免所有请求直接访问数据库。
		- **设置缓存数据的随机过期时间**：在设置缓存数据的过期时间时，加上一个随机值，使得不同的缓存数据在过期时刻不一致。这样可以避免大量数据同时过期，减轻数据库负荷。